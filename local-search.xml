<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>存储过程和触发器</title>
    <link href="/blog/2022/04/02/mysql/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/blog/2022/04/02/mysql/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>存储过程：是一个可编程的函数，它在数据库中创建并保存，由 SQL 语句和一些特殊的控制结构组成。将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。</p><h3 id="MySQL创建存储过程（CREATE-PROCEDURE）"><a href="#MySQL创建存储过程（CREATE-PROCEDURE）" class="headerlink" title="MySQL创建存储过程（CREATE PROCEDURE）"></a>MySQL创建存储过程（CREATE PROCEDURE）</h3><p>CREATE PROCEDURE &lt;过程名&gt; ( [过程参数[,…] ] ) &lt;过程体&gt;</p><p>[过程参数[,…] ] 格式[ IN | OUT | INOUT ] &lt;参数名&gt; &lt;类型&gt;</p><ol><li><p>过程名：若需要在特定数据库中创建存储过程，则要在名称前面加上数据库的名称，即 db_name.sp_name。</p></li><li><p>过程参数：可以有 1 个或多个参数，当有多个参数时，参数列表中彼此间用逗号分隔。可以没有参数，此时存储过程的名称后仍需加上一对括号。</p></li></ol><ul><li>输入参数、输出参数和输入&#x2F;输出参数，分别用 IN、OUT 和 INOUT 三个关键字标识。输</li><li>入参数可以传递给一个存储过程，输出参数用于存储过程需要返回一个操作结果的情形，而输入&#x2F;输出参数既可以充当输入参数也可以充当输出参数。</li></ul><ol start="3"><li>过程体：存储过程的主体部分，包含在过程调用的时候必须执行的 SQL 语句。这个部分以关键字 BEGIN 开始，以关键字END 结束</li></ol><h3 id="MySQL查看存储过程"><a href="#MySQL查看存储过程" class="headerlink" title="MySQL查看存储过程"></a>MySQL查看存储过程</h3><blockquote><p>SHOW CREATE PROCEDURE 存储过程名</p></blockquote><h3 id="MySQL删除存储过程（DROP-PROCEDURE）"><a href="#MySQL删除存储过程（DROP-PROCEDURE）" class="headerlink" title="MySQL删除存储过程（DROP PROCEDURE）"></a>MySQL删除存储过程（DROP PROCEDURE）</h3><p>DROP PROCEDURE [ IF EXISTS ] &lt;过程名&gt;</p><ul><li>过程名：指定要删除的存储过程的名称。</li><li>IF EXISTS：指定这个关键字，用于防止因删除不存在的存储过程而引发的错误</li></ul><h3 id="MySQL调用存储过程"><a href="#MySQL调用存储过程" class="headerlink" title="MySQL调用存储过程"></a>MySQL调用存储过程</h3><p>CALL sp_name ( [parameter […] ] ) ;<br>其中，sp_name 表示存储过程的名称，parameter 表示存储过程的参数。</p><h3 id="MySQL存储函数"><a href="#MySQL存储函数" class="headerlink" title="MySQL存储函数"></a>MySQL存储函数</h3><ul><li><p>存储函数和存储过程一样，都是在数据库中定义一些 SQL 语句的集合。存储函数可以通过 return 语句返回函数值，主要用于计算并返回一个值。而存储过程没有直接返回值，主要用于执行操作。</p></li><li><p>REATE FUNCTION sp_name ([func_parameter[…]])</p></li><li><p>RETURNS type [characteristic …] routine_body</p></li><li><p>sp_name 参数：表示存储函数的名称；</p></li><li><p>func_parameter：表示存储函数的参数列表；</p></li><li><p>RETURNS type：指定返回值的类型；</p></li><li><p>characteristic 参数：指定存储函数的特性，该参数的取值与存储过程是一样的；</p></li><li><p>routine_body 参数：表示 SQL 代码的内容，可以用 BEGIN…END 来标示 SQL 代码的开始和结束。</p></li><li><p>func_parameter 可以由多个参数组成，其中每个参数由参数名称和参数类型组成</p></li><li><p>SELECT func_student(3); #调用存储函数</p></li></ul><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器和存储过程一样，都是嵌入到 MySQL 中的一段程序 。不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行是通过对数据表的相关操作来触发执行。比如当对 student 表进行操作（INSERT，DELETE 或 UPDATE）时就会激活它执行。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>触发器的执行是自动的，当对触发器相关表的数据做出相应的修改后立即执行。 </li><li>触发器可以实施比 FOREIGN KEY 约束、CHECK 约束更为复杂的检查和操作。 </li><li>触发器可以实现表数据的级联更改，在一定程度上保证了数据的完整性。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>使用触发器实现的业务逻辑在出现问题时很难进行定位，特别是涉及到多个触发器的情况下，会使后期维护变得困难</li><li>大量使用触发器容易导致代码结构被打乱，增加了程序的复杂性，</li><li>如果需要变动的数据量较大时，触发器的执行效率会非常低</li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql存储引擎</title>
    <link href="/blog/2018/11/16/mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <url>/blog/2018/11/16/mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<ul><li>是数据库管理系统（DBMS）的核心软件组件， 决定了表在计算机中的</li><li>MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。 不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。</li><li>MySQL 5.5 后，默认存储引擎由 MyISAM 修改为 InnoDB。</li><li>MySQL 5.7 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、CSV、BLACKHOLE 等。</li></ul><p><img src="/blog/images/mysql&linux/engine1.jpg"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">查看系统所支持的引擎类型<br><span class="hljs-keyword">SHOW</span> ENGINES;<br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;default_storage_engine%&#x27;</span>;  // 查看默认存储引擎<br><br>临时修改默认存储引擎<br><span class="hljs-keyword">SET</span> default_storage_engine=&lt; 存储引擎名 &gt;<br>再次重启客户端时失效，默认存储引擎仍然是 InnoDB。<br><br>永久修改默认的存储引擎<br>在my.cnf 配置文件  [mysqld] 后面加入以下语句：<br><span class="hljs-keyword">default</span>-<span class="hljs-keyword">storage</span>-engine=存储引擎名称<br>然后保存就可以了。<br></code></pre></td></tr></table></figure><h2 id="行级锁和表级锁"><a href="#行级锁和表级锁" class="headerlink" title="行级锁和表级锁"></a>行级锁和表级锁</h2><blockquote><p>表级锁：&lt;表级锁就是可以锁住表，当同时进行某些操作，只能锁住表，比如我对这个表进行写操作，其他人不能进行操作，不能读写，比如我写操作，就把这张表锁住，我写完了，其他人才能来做操作&gt;<br>行级锁：&lt;可以锁到某条记录，比如不能同时对某一行做某些操作&gt;<br>行级锁更加精细，适用于比如抢票下单业务，下单时锁住某一张票，其他人就不能抢这张票，但是可以抢其他的票</p></blockquote><h2 id="MySQL-InnoDB存储引擎"><a href="#MySQL-InnoDB存储引擎" class="headerlink" title="MySQL InnoDB存储引擎"></a>MySQL InnoDB存储引擎</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>支持事务 ：实现了 SQL92 标准所要求的数据隔离级别 。 </li><li>使用行级锁 ： 通过索引来完成行锁机制 </li><li>实现了缓冲处理 ：提供了专门的缓存池，实现了缓冲管理，不仅能缓冲索引也能缓冲数据，常用的数据可以直接从内存中处理，比从磁盘获取数据处理速度要快。相比之下，MyISAM 只是缓存了索引。 </li><li>支持外键约束: 检查外键、插入、更新和删除，以确保数据的完整性。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>使用 InnoDB 存储引擎的读写效率稍差，且占用的数据空间相对较大&lt;因为他日志多，比如回滚操作，肯定是将一些操作记录了下来，回滚的时候翻旧账&gt;，不过他安全，拿空间换安全</li></ol><h2 id="MySQL-MyISAM-存储引擎"><a href="#MySQL-MyISAM-存储引擎" class="headerlink" title="MySQL MyISAM 存储引擎"></a>MySQL MyISAM 存储引擎</h2><blockquote><p>MyISAM 是一直作为 MySQL 数据库的默认存储引擎，直到 MySQL 5.5 版本才被 InnoDB 引擎取代了默认存储引擎的地位。</p></blockquote><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>占用空间小 </li><li>访问速度快，对事务完整性没有要求，或以 SELECT、INSERT 为主的应用基本上都可以使用这个引擎来创建表。比如像数据交易系统，对于数据一致性有极高的要求，绝对不能出错，这种就不适合MyISAM存储引擎。而对于数据分析型的系统，一次插入多次查询的比如数据仓库，这种就适用于MyISAM </li><li>可以配合锁，实现操作系统下的复制备份 </li><li>支持全文检索（InnoDB 在 MySQL 5.6 版本以后也支持全文检索） </li><li>数据紧凑存储&lt;数据紧凑存储：数据之间碎片化少，所以在读取时 一下子扫描一大片，寻址的过程就很少&gt;，因此可获得更小的索引和更快的全表扫描性能。</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>不支持事务,不能保证数据的一致性 </li><li>不支持行级锁，使用表级锁，并发性差&lt;表锁了之后，别人没法操作，所以并发差&gt;</li><li>数据查询崩溃后无法安全恢复 </li><li>只缓存索引，数据的缓存是利用操作系统缓冲区来实现的</li></ol><h2 id="MySQL存储引擎如何选择"><a href="#MySQL存储引擎如何选择" class="headerlink" title="MySQL存储引擎如何选择"></a>MySQL存储引擎如何选择</h2><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><ul><li>如果应用主要以读取和写入为主，只有少量的更新和删除操作，并且对事务的完整性、并发性要求不是很高，可以选择 MyISAM 存储引擎 。</li><li>对于数据分析型的系统，一次插入多次查询的比如数据仓库，这种就适用于MyISAM</li><li>MyISAM 是在 数据仓储 最常使用的存储引擎之一。</li></ul><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><ul><li>如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、删除操作，那么 InnoDB 存储引擎是比较合适的选择。</li></ul><h4 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h4><p>MEMORY 存储引擎将所有数据保存在 内存 中，所以该存储引擎的数据访问速度快，但是安全上没有保障</p><p><img src="/blog/images/engine2.jpg"></p><h2 id="MySQL修改数据表的存储引擎"><a href="#MySQL修改数据表的存储引擎" class="headerlink" title="MySQL修改数据表的存储引擎"></a>MySQL修改数据表的存储引擎</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> ENGINE<span class="hljs-operator">=</span><span class="hljs-operator">&lt;</span>存储引擎名<span class="hljs-operator">&gt;</span>;<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student \G #查看 student 表当前的存储引擎<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> student ENGINE<span class="hljs-operator">=</span>MyISAM; <br>#将 student 表的存储引擎修改为 MyISAM 类型，在数据多的时候比较慢，影响读取性能，推荐一个比第一种速度快， 安全性高的跟新策略，如下：<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>; # 开始事务<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> my_tmp_table <span class="hljs-keyword">LIKE</span> my_table; # 创建表,先创建一个和要操作表一样的表<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> my_tmp_table ENGINE=InnoDB; # 然后更改存储引擎为目标引擎<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> my_tmp_table <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> my_table; # 插入。<br><span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TABLE</span> my_table <span class="hljs-keyword">to</span> my_table_MyISAM_20201230backup; # 原表命名为备份表<br><span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TABLE</span> my_tmp_table <span class="hljs-keyword">to</span> my_table ; # 临时表上位<br><span class="hljs-keyword">COMMIT</span>; # 提交事物<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库设计方法论</title>
    <link href="/blog/2018/10/02/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <url>/blog/2018/10/02/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库设计的基本步骤"><a href="#数据库设计的基本步骤" class="headerlink" title="数据库设计的基本步骤"></a>数据库设计的基本步骤</h1><blockquote><p>需求分析：是数据库设计的第一步，是最困难、最耗费时间的一步，也是整个设计过程的基础。<br>概要设计：是数据库设计的关键，通过综合、归纳与抽象用户需求，形成一个具体 DBMS 的概念模型，也就是绘制数据库的 E-R 图。<br>逻辑结构设计：将 E-R 图转换为多张表，进行逻辑设计，确认各表的主外键，并应用数据库设计的三大范式进行审核，对其优化。<br>物理设计阶段：确定 E-R 图后，根据项目的技术实现，团队开发能力及项目的成本预算，选择具体的数据库（如 MySQL 或 Oracle 等）进行物理实现。<br>数据库实施：运用 DBMS 提供的数据语言（例如 SQL）、工具及宿主语言（例如 Java），根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。<br>数据库运行和维护：数据库应用系统经过试运行后即可投入正式运行。在运行过程中必须不断地对其进行评价、调整与修改。<br>总之设计一个完善的数据库应用系统是不可能一蹴而就的，它是上述 6 个阶段的不断反复</p></blockquote><h2 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h2><h3 id="E-R图介绍"><a href="#E-R图介绍" class="headerlink" title="E-R图介绍"></a>E-R图介绍</h3><blockquote><p>为什么要叫关系型数据库，是因为关系型数据库就是在研究实体与实体的关系，属性与属性的关系<br>E-R图是设计数据库的工具之一，用于建立数据库的概念模型。<br>实体、属性和关系是构成 E-R图的基本要素。</p></blockquote><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><ul><li>指现实世界中客观存在并可以相互区分的对象或事物。</li><li>实体往往指某类事物的集合。可以是具体的人和事物，也可以是抽象的概念、联系。</li><li>实体一般是名词，对应表中的一行数据。例如，用户张三是一个实体，他对应于客人表中“张三”所在的一行数据，包括客人姓名、身份证号等信息。</li><li>严格的说，实体用来指表中的一行特定数据。但在开发时，我们也常常把表称为一个实体。</li></ul><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li>可以理解为实体的特征。</li></ul><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><ul><li>两个或多个实体之间的关联关系。</li><li>关系可分为以下 4 种类型，例如对于实体 X 和 Y 之间的关系就必须为以下任意一种：<ul><li>一对一:X 中的一个实体最多与 Y 中的一个实体关联，并且 Y 中的一个实体最多与 X 中的一个实体关联。 </li><li>一对多:X 中的一个实体可以与 Y 中任意数量的实体关联，Y 中的一个实体最多与 X 中的一个实体关联。 </li><li>多对一:X 中的一个实体最多与 Y 中的一个实体关联，Y 中的一个实体可以与 X 中的任意数量的实体关联。 </li><li>多对多:X 中的一个实体可以与 Y 中的任意数量的实体关联，反之亦然。</li></ul></li></ul><h3 id="绘制ER图"><a href="#绘制ER图" class="headerlink" title="绘制ER图"></a>绘制ER图</h3><p>E-R 图以图形的方式来表示数据库的整个逻辑结构，如下：<br>实体：用矩形表示<br>属性：用椭圆形表示<br>关系：用菱形表示<br>使用直线连接属性和实体，以及连接实体和关系</p><p><img src="/blog/images/WEBRESOURCEc8ed773eefcbc91783928825fb5c0df0%E6%88%AA%E5%9B%BE.png"></p><h2 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h2><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><blockquote><p>数据库范式(Normal form，简称NF) ：理解就是按照面向对象的思想 拆分到不能拆分为止符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度 。 数据库模型设计的一系列规范 ，分成6个等级，一级比一级要求得严格。满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入(insert)、删除(delete)和更新(update)操作异常。避免不需要的数据冗余<br>逻辑主键：哪个字段 或者哪几个字段 加在一起，这条数据不会重复，就是逻辑主键</p></blockquote><h4 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h4><p>强调列的原子性，拆到不能再拆</p><p><img src="/blog/images/WEBRESOURCEa9a08b63b4500123dbdb098c36340347%E6%88%AA%E5%9B%BE.png"></p><p><img src="/blog/images/WEBRESOURCE548f2769b62bbbdb03a0d46ba5004a20%E6%88%AA%E5%9B%BE.png"></p><h4 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h4><p>在满足1NF的基础上，非主属性必须完全依赖于主属性，部分依赖&lt;比如学号和科目为主属性。姓名依赖于学号，但是不依赖于科目。即非主属性只依赖于主属性的一部分&gt;则不符合2NF</p><p><img src="/blog/images/1725093391910.jpg"></p><h4 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h4><p>消除非主属性传递依赖主属性</p><p><img src="/blog/images/1725093505827.jpg"></p><p>巴斯-科德范式（Boyce-Codd Normal Form ，BCNF）在3NF基础上，任何非主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）</p><h3 id="反范式"><a href="#反范式" class="headerlink" title="反范式"></a>反范式</h3><p>• 范式越高意味着表的划分更细，一个数据库中需要的表也就越多，用户不得不将原本相关联的数据分摊到多个表中。同时把多个表联接在一起的花费是巨大的， 这严重地降低了系统运行性能。<br>• 反范式化的数据库因为所有的数据都在一张表中，可以很好地避免关联。<br>• 平时工作中，我们通常是将范式和反范式混合使用，相互结合。</p><h3 id="数据库范式化和反范式化："><a href="#数据库范式化和反范式化：" class="headerlink" title="数据库范式化和反范式化："></a>数据库范式化和反范式化：</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>可以减少表的关联</li><li>可以更好的进行索引优化</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>数据表存在数据冗余及数据维护异常，空间换时间</li><li>对数据的修改需要更多的成本</li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁和事务</title>
    <link href="/blog/2018/09/18/mysql/%E9%94%81%E5%92%8C%E4%BA%8B%E7%89%A9/"/>
    <url>/blog/2018/09/18/mysql/%E9%94%81%E5%92%8C%E4%BA%8B%E7%89%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL锁机制"><a href="#MySQL锁机制" class="headerlink" title="MySQL锁机制"></a>MySQL锁机制</h1><ul><li>锁机制: 是为了保证数据库并发访问时的一致性和有效性的一系列规则。锁机制的优劣直接影响到数据库的并发处理能力和系统性能，所以锁机制也就成为了各种数据库的核心技术之一。</li></ul><h2 id="按锁级别分类"><a href="#按锁级别分类" class="headerlink" title="按锁级别分类"></a>按锁级别分类</h2><ul><li>可分为共享锁、排他锁和意向锁 <ul><li>共享锁(S,是Share的缩写，也称读锁): 锁粒度是行或者元组（多个行）。一个事务获取了共享锁之后，可以对锁定范围内的数据执行读操作。会阻止其它事务获得相同数据集的排他锁X。上了读锁的数据，其他事务只能读取，不能被修改和删除。</li><li>排他锁(X,是eXclusive的缩写，也称写锁): 锁粒度是行或者元组。一个事务获取了排他锁之后，可以对锁定范围内的数据执行写操作。阻止其它事务取得相同数据集的共享锁S和排他锁X。上了写锁的数据只能被当前事务修改和删除，其他事务不能读也不能写。</li><li>意向锁：锁定的粒度是整张表，分为意向共享锁（IS）和意向排他锁（IX）两类。“意向”表示事务想执行但还没有真正执行</li></ul></li></ul><h2 id="MySQL-锁机制的相容和互斥"><a href="#MySQL-锁机制的相容和互斥" class="headerlink" title="MySQL 锁机制的相容和互斥"></a>MySQL 锁机制的相容和互斥</h2><ul><li>锁和锁之间的关系，要么是相容的，要么是互斥的。</li><li>锁a和锁b相容是指：操作同样一组数据时，如果事务t1获取了锁a，另一个事务t2还可以获取锁b；</li><li>锁a和锁b互斥是指：操作同样一组数据时，如果事务t1获取了锁 a，另一个事务t2在t1释放锁 a 之前无法释放锁b。</li><li>锁模式的兼容情况 其中Y表示相容，N表示互斥。</li></ul><p><img src="/blog/images/WEBRESOURCE61e8039a40a805c0085374c5dd75149c%E6%88%AA%E5%9B%BE.png"></p><ul><li>为了尽可能提高数据库的并发量; 需每次锁定的数据范围越小越好，越小的锁其耗费的系统资源越多，系统性能下降。为在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度”的概念</li></ul><h2 id="按锁的粒度分类"><a href="#按锁的粒度分类" class="headerlink" title="按锁的粒度分类"></a>按锁的粒度分类</h2><ul><li>可以细分为行级锁、页级锁和表级锁</li></ul><h3 id="表级锁（table-lock）"><a href="#表级锁（table-lock）" class="headerlink" title="表级锁（table lock）"></a>表级锁（table lock）</h3><ul><li>会锁定整张表，可以很好的避免死锁，是 MySQL 中最大颗粒度的锁定机制。</li><li>一个用户在对表进行写操作（插入、删除、更新等）时，需要先获得写锁，这会阻塞其它用户对该表的所有读写操作。没有写锁时，其它读取的用户才能获得读锁，读锁之间是不相互阻塞的 </li><li>表级锁最大的特点就是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。• 出现锁定资源争用的概率会很高，致使并发度大打折扣。 </li><li>使用表级锁的主要是 MyISAM，MEMORY，CSV 等一些非事务性存储引擎。</li><li>尽管存储引擎可以管理自己的锁，MySQL 本身还是会使用各种有效的表级锁来实现不同的目的。例如，服务器会为诸如 ALTER TABLE 之类的语句使用表级锁，而忽略存储引擎的锁机制</li></ul><h3 id="页级锁（page-lock）"><a href="#页级锁（page-lock）" class="headerlink" title="页级锁（page lock）"></a>页级锁（page lock）</h3><ul><li>页级锁是 MySQL 中比较独特的一种锁定级别，在其他数据库管理软件中并不常见。</li><li>页级锁的颗粒度介于行级锁与表级锁之间，资源开销，并发处理能力也是介于上面二者之间。</li><li>页级锁和行级锁一样，会发生死锁。</li><li>页级锁主要应用于 BDB 存储引擎。</li></ul><h3 id="行级锁（row-lock）"><a href="#行级锁（row-lock）" class="headerlink" title="行级锁（row lock）"></a>行级锁（row lock）</h3><ul><li>行级锁的锁定颗粒度是最小的，只针对操作的当前行进行加锁，所以行级锁发生锁定资源争用的概率也最小。</li><li>最大程度地支持并发处理。</li><li>每次获取锁和释放锁，系统消耗较大</li><li>容易发生死锁。</li><li>行级锁主要应用于 InnoDB 存储引擎</li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ul><li><p><strong>数据库的事务（Transaction）</strong> 是一种机制、一个操作序列，包含了一组数据库操作命令。事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行 。保障数据有效性</p></li><li><p>事务具有 4 个特性：简称为 ACID</p><ul><li><strong>• 原子性（Atomicity）</strong>: 所有元素必须作为一个整体提交或回滚。如果事务中的任何元素失败，则整个事务将失败。</li><li><strong>• 一致性（Consistency）</strong>: 是事务机制的目的，保障数据与现实业务的一致。一致性：就是保证不出现错误的数据，保持数据与我们想要的结果一致，不会因为底层操作而被篡改等等</li><li><strong>• 隔离性（Isolation）</strong>: 所有并发事务是彼此隔离的，独立的。不以任何方式依赖于或影响其他事务。</li><li><strong>• 持久性（Durability）</strong>: 事务被提交，事务对数据所做的任何变动都会被永久地保留在数据库中</li></ul></li><li><p>InnoDB 存储引擎事务主要通过 UNDO 日志和 REDO 日志实现，MyISAM 存储引擎不支持事务。</p><ul><li>UNDO 日志 ：复制事务执行前的数据，用于在事务发生异常时回滚数据。 </li><li>REDO 日志 ：记录在事务执行中，每条对数据进行更新的操作，当事务提交时，该内容将被刷新到磁盘。 </li><li>默认设置下，每条SQL 语句就是一个事务，即执行SQL语句后自动提交。 </li><li>为了达到将几个操作做为一个整体的目的，需要使用<blockquote><p><strong>BEGIN 或 START TRANSACTION</strong> #开启一个事务，或者禁止当前会话的自动提交。<br>**COMMIT; **表示提交事务， 将事务中所有对数据库的更新都写到磁盘上的物理数据库中，事务正常结束。<br>**ROLLBACK; **:表示撤销事务， 事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始时的状态</p></blockquote></li></ul></li></ul><h1 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h1><h3 id="演示设置，方便复现"><a href="#演示设置，方便复现" class="headerlink" title="演示设置，方便复现"></a>演示设置，方便复现</h3><blockquote><p>为了演示锁等待效果，让锁等待长一些，不然很快就 终止等待了.等待语句并未执行。事务也不回滚。<br>SHOW VARIABLES LIKE ‘%innodb_lock_wait%’; # 查看 锁等待超时时间<br>set innodb_lock_wait_timeout&#x3D;300 ;        # 设置锁等待超时秒数 。如果并未杀掉持有锁的线程：则第二个update语句提示等待锁超时</p><p>SHOW VARIABLES LIKE ‘%innodb_deadlock%’;<br>set global innodb_deadlock_detect &#x3D;off ;         # 为了演示死锁 ，把死锁检测 关闭。</p></blockquote><h3 id="事物及行级锁演示"><a href="#事物及行级锁演示" class="headerlink" title="事物及行级锁演示"></a>事物及行级锁演示</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 创建一个Innodb 的表<br># 课上演示翻车 ，就是因为上次课修改了 会话参数 默认存储引擎 为 MyISAM ，未修改回来，导致建表 默认成了MyISAM，不支持事务 。<br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;default_storage_engine%&#x27;</span>;<br>#临时修改默认存储引擎<br># <span class="hljs-keyword">SET</span> default_storage_engine=&lt; 存储引擎名 &gt;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> account(<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">primary key</span> ,<br>    <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) ,<br>    balance <span class="hljs-type">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">2</span>)<br>   )ENGINE=innodb ;   # 保险起见 ，加上存储引擎限制 。<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;刘备&#x27;</span>,<span class="hljs-number">1000</span>) , (<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;张飞&#x27;</span>,<span class="hljs-number">1</span>) ;<br><br><br># <span class="hljs-comment">-------A会话： 运用 事务进行转账操作</span><br><span class="hljs-keyword">BEGIN</span>;          # 开始A事务 和 <span class="hljs-keyword">START</span>  <span class="hljs-keyword">TRANSACTION</span>等效 ， 转账事务 <br>   #   第<span class="hljs-number">1</span>步 ，从转出账户转出金额 ，即更新 转出账户金额 自减 <span class="hljs-number">500</span>元 ；<br>   #获取行级写锁<span class="hljs-number">1</span> ，在提交事务之前，其他的事务不能修改此条数据 。不信？ 你可以在B事务 更新试试，看看什么效果<br>  <span class="hljs-keyword">UPDATE</span> account<br>  <span class="hljs-keyword">SET</span> balance = balance<span class="hljs-number">-500</span><br>  <span class="hljs-keyword">WHERE</span>  id=<span class="hljs-number">1</span>  #  <span class="hljs-string">&#x27;刘备&#x27;</span><br>  ;<br>  #   第<span class="hljs-number">2</span>步 ，转入账户接收金额 ，即更新 转入账户金额 自加 <span class="hljs-number">500</span>元 ；<br>   #获取行级写锁<span class="hljs-number">2</span> ，在提交事务之前，其他的事务不能修改此条数据<br>  <span class="hljs-keyword">UPDATE</span> account<br>  <span class="hljs-keyword">SET</span> balance = balance+<span class="hljs-number">500</span><br>  <span class="hljs-keyword">WHERE</span>  id=<span class="hljs-number">2</span>   #  <span class="hljs-string">&#x27;张飞&#x27;</span> ， 获取行级写锁  <span class="hljs-number">2</span><br>  ;<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> test_db.account;   # 查看事务内部过程 数据<br><br># <span class="hljs-comment">-------B会话：  在A事务提交之前， 查看账户信息</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> test_db.account;  # 对比 A事务内部结果 ，发现结果不一致，说明事务的 “隔离性”。<br># <span class="hljs-comment">-------继续在 B会话操作：</span><br><span class="hljs-keyword">BEGIN</span>;  # 开始B事务 , 不知道A事务在转账 ，二不拉几的也 在执行转账，我们看他是怎么搞乱世界的。<br>      #   第<span class="hljs-number">1</span>步 ，他竟然先 让接收账户接收 转账金额， 增加了<span class="hljs-number">500</span> ；<br> <span class="hljs-keyword">UPDATE</span> account <span class="hljs-keyword">SET</span> balance = balance+<span class="hljs-number">500</span><br>           <span class="hljs-keyword">WHERE</span>  id=<span class="hljs-number">2</span>  # <span class="hljs-type">Name</span>=<span class="hljs-string">&#x27;张飞&#x27;</span>;   # 如果A未提交，你会发现 此条语句卡住了<br># 切换到A 会话 执行提交动作 。 注意观察 ，B事务 同时执行成功，返回执行结果<br> <span class="hljs-keyword">commit</span>；<br>  <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> test_db.account; # 看看更新效果<br><span class="hljs-keyword">ROLLBACK</span>;    #  可以试验一下回滚操作 好不好使 ，说明事务 的  “原子性”<br> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> test_db.account;  # 验证一下是否回滚<br></code></pre></td></tr></table></figure><h6 id="死锁演示"><a href="#死锁演示" class="headerlink" title="死锁演示"></a>死锁演示</h6><blockquote><p>我要的东西在你手里，你要的东西在我手里</p></blockquote><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta">##### 死锁 演示 ：新建两个 会话 ，A 和B</span><br><span class="hljs-meta"># 1、在A会话 ： 锁住 id=1 的记录</span><br> UPDATE account<br>  SET balance = <span class="hljs-built_in">balance</span><span class="hljs-number">-500</span><br>  <span class="hljs-built_in">WHERE</span>  id=<span class="hljs-number">1</span>  <span class="hljs-meta">#  &#x27;刘备&#x27;</span><br>  ;<br><span class="hljs-meta"># 2、在B会话： 锁住 id=2 的记录</span><br> UPDATE account<br>  SET balance = <span class="hljs-built_in">balance</span>+<span class="hljs-number">500</span><br>  <span class="hljs-built_in">WHERE</span>  id=<span class="hljs-number">2</span>  <span class="hljs-meta">#  &#x27;张飞&#x27;</span><br>  ;<br><span class="hljs-meta">#3、在A会话 ：执行id=2的修改，即索要id=2的写锁 ，但是 此数据已被B 抢先锁住，A进入等待</span><br>UPDATE account<br>  SET balance = <span class="hljs-built_in">balance</span>+<span class="hljs-number">500</span><br>  <span class="hljs-built_in">WHERE</span>  id=<span class="hljs-number">2</span>  <span class="hljs-meta">#  &#x27;张飞&#x27;</span><br>  ;<br><span class="hljs-meta">#4、在B会话：执行 id=1 的修改，即索要id=1的写锁，但是 此数据已被 A抢先锁住，A、B进入死锁</span><br><span class="hljs-meta">#此时 如 innodb_deadlock_detect =on ，则此语句终止，避免死锁。否则一直等待</span><br> UPDATE account<br>  SET balance = <span class="hljs-built_in">balance</span><span class="hljs-number">-500</span><br>  <span class="hljs-built_in">WHERE</span>  id=<span class="hljs-number">1</span>  <span class="hljs-meta">#  &#x27;刘备飞&#x27;</span><br>  ;<br><span class="hljs-meta"># 如果从业务流程上规范： 一律先执行扣减，再执行加钱，即可避免死锁 。</span><br><span class="hljs-meta"># 就是说，会话B 也先执行id=1的变更 ，他就会跟着 A 后面顺利执行，顶多等待一会儿，而不会死锁。</span><br><br>set autocommit = <span class="hljs-number">0</span>; <span class="hljs-meta"># 取消自动提交,只有当执行 commit才提交 。</span><br><br><span class="hljs-built_in">SELECT</span> * FROM INFORMATION_SCHEMA.INNODB_TRX ;        <span class="hljs-meta">#查询 正在执行的事务：</span><br><span class="hljs-built_in">SELECT</span> * FROM INFORMATION_SCHEMA.INNODB_LOCKS ;      <span class="hljs-meta">#查询 正在锁的事务 ,Mysql 8.0版本 以前</span><br> <span class="hljs-built_in">SELECT</span> * FROM performance_schema.data_locks\G ；     <span class="hljs-meta">#查询 正在锁的事务 ,Mysql 8.0版本 以后</span><br><span class="hljs-built_in">SELECT</span> * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS ; <span class="hljs-meta">#查询 等待锁的事务,Mysql 8.0版本 以前</span><br><span class="hljs-built_in">SELECT</span> * FROM performance_schema.data_lock_waits\G ; <span class="hljs-meta">#查询 等待锁的事务,Mysql 8.0版本 以后</span><br><span class="hljs-built_in">select</span> * from INFORMATION_SCHEMA.`PROCESSLIST` ;   <span class="hljs-meta">#查询mysql数据库中存在的进程</span><br><span class="hljs-keyword">show</span> processlist;<br><span class="hljs-keyword">show</span> full processlist; <span class="hljs-meta">#查询进程列表— #返回的结果是实时变化的，是对mysql链接执行的现场快照，所以用来处理突发事件非常有用。</span><br> <span class="hljs-meta">#它可以查看当前mysql的一些运行情况，是否有压力，都在执行什么sql，语句耗时时间，有没有慢sql在执行等等。</span><br><span class="hljs-meta">#当发现一些执行时间很长的sql时，就需要多注意一下了，必要时kill掉，先解决问题。</span><br><br>kill 线程id <span class="hljs-meta">#杀掉线程</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql视图</title>
    <link href="/blog/2018/06/18/mysql/%E8%A7%86%E5%9B%BE/"/>
    <url>/blog/2018/06/18/mysql/%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="视图介绍"><a href="#视图介绍" class="headerlink" title="视图介绍"></a>视图介绍</h2><p>视图（View）是一种虚拟存在的表，并不实际存在于数据库中，相当于一个子查询。</p><blockquote><ol><li>定制用户数据在实际的应用过程中，不同的用户可能对不同的数据有不同的要求，聚焦特定的数据。</li><li>简化数据操作在使用查询时，很多时候要使用聚合函数，同时还要显示其他字段的信息，可能还需要关联到其他表，语句可能会很长，如果这个动作频繁发生的话，可以创建视图来简化操作。</li><li>提高数据的安全性视图是虚拟的，物理上是不存在的。可以只授予用户视图的权限，而不具体指定使用表的权限，来保护基础数据的安全。</li><li>共享所需数据通过使用视图，每个用户不必都定义和存储自己所需的数据，可以共享数据库中的数据，同样的数据只需要存储一次。</li><li>重用 SQL 语句视图提供的是对查询操作的封装，本身不包含数据，所呈现的数据是根据视图定义从基础表中检索出来的，如果基础表的数据新增或删除，视图呈现的也是更新后的数据。视图定义后，编写完所需的查询，可以方便地重用该视图</li></ol></blockquote><h2 id="MySQL视图管理"><a href="#MySQL视图管理" class="headerlink" title="MySQL视图管理"></a>MySQL视图管理</h2><h5 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h5><blockquote><p><strong>CREATE VIEW &lt;视图名&gt; AS &lt;SELECT语句&gt;</strong><br>•&lt;视图名&gt;：指定视图的名称。该名称在数据库中必须是唯一的，不能与其他表或视图同名。<br>•&lt;SELECT语句&gt;：指定创建视图的 SELECT 语句，可用于查询多个基础表或源视图。</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">MySQL创建视图（<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> view_student   <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student; //  相当于：<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student) <span class="hljs-keyword">as</span> view_student;  就是个子查询<br>  <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> view_student;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> v_students_info (s_id,s_name,d_id,s_age,s_sex,s_height,s_date)<br>    <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> id,<span class="hljs-type">name</span>,deptid,age,sex,height,login_date <span class="hljs-keyword">FROM</span> student;<br><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span>; 查看视图是否创建成功<br>DESCRIBE v_students_info;  # 查看视图结构<br><span class="hljs-keyword">desc</span> v_students_info;<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> v_students_info<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> v_students_info \G;  // 可读性更强<br></code></pre></td></tr></table></figure><h5 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h5><blockquote><p><strong>ALTER VIEW &lt;视图名&gt; AS &lt;SELECT语句&gt;</strong><br>•&lt;视图名&gt;：指定视图的名称。该名称在数据库中必须是唯一的，不能与其他表或视图同名。<br>•&lt;SELECT语句&gt;：指定创建视图的 SELECT 语句，可用于查询多个基础表或源视图。</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">#修改视图（<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">VIEW</span>） 就是保留<span class="hljs-keyword">view</span>的名称，把<span class="hljs-keyword">sql</span>调整下<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">VIEW</span> view_student<br>     <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> id,<span class="hljs-type">name</span>,age <span class="hljs-keyword">FROM</span> student;<br> <span class="hljs-keyword">DESC</span> view_students_info;<br></code></pre></td></tr></table></figure><h5 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h5><blockquote><p><strong>DROP VIEW &lt;视图名1&gt; [ , &lt;视图名2&gt; …]</strong><br>其中：&lt;视图名&gt;指定要删除的视图名。DROP VIEW 语句可以一次删除多个视图</p></blockquote><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 删除视图</span><br><span class="hljs-built_in">DROP</span> <span class="hljs-built_in">VIEW</span> <span class="hljs-keyword">IF</span> EXISTS v_students_info;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引</title>
    <link href="/blog/2018/06/17/mysql/%E7%B4%A2%E5%BC%95/"/>
    <url>/blog/2018/06/17/mysql/%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql-索引介绍"><a href="#mysql-索引介绍" class="headerlink" title="mysql 索引介绍"></a>mysql 索引介绍</h1><p>索引是一种特殊的数据库结构，可以用来快速查询数据表中有某一特定值的记录。</p><ul><li><p><strong>可以把索引比作新华字典的音序表。</strong> 例如，要查“库”字，如果不使用音序，就需要从字典的 400 页中逐页来找。但是，如果提取拼音出来，构成音序表，就只需要从 10 多页的音序表中直接查找。这样就可以大大节省时间。</p></li><li><p><strong>1) 顺序访问</strong> 在表中实行全表扫描，从头到尾逐行遍历，直到在无序的行数据中找到符合条件的目标数据。顺序访问实现比较简单，效率非常低下。例如，在几千万条数据中查找少量的数据时，使用顺序访问方式将会遍历所有的数据，花费大量的时间，显然会影响数据库的处理性能</p></li><li><p><strong>2) 索引访问</strong>通过遍历索引来直接访问表中记录行的方式。使用这种方式的前提是对表建立一个索引，查找数据时可以直接根据该列上的索引找到对应记录行的位置，从而快捷地查找到数据。</p></li><li><p>索引存储了指定列数据值的指针，根据指定的排序顺序对这些指针排序。索引是很小的，而且通常读在内存中</p></li></ul><h2 id="MySQL-索引的优缺点"><a href="#MySQL-索引的优缺点" class="headerlink" title="MySQL 索引的优缺点"></a>MySQL 索引的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>通过创建唯一索引可以保证数据库表中每一行数据的<strong>唯一性。</strong></p></li><li><p>可以给所有的 MySQL 列类型设置索引。</p></li><li><p>可以<strong>大大加快数据的查询速度</strong>，这是使用索引最主要的原因。</p></li><li><p>在实现数据的参考完整性方面可以加速表与表之间的连接。</p></li><li><p>在使用分组和排序子句进行数据查询时也可以显著减少查询中分组和排序的时间</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>创建和维护索引组要耗费时间，并且随着数据量的增加所耗费的时间也会增加。</li><li>索引需要占磁盘空间，除了数据表占数据空间以外，每一个索引还要占一定的物理空间。如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。</li><li><strong>当对表中的数据进行增加、删除和修改的时候，索引也要动态维护，这样就降低了数据的维护速度。插入海量数据时，最好的办法是先删除表中的索引，然后插入数据，插入完成后，再创建索引</strong></li></ul><h1 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a>创建索引的原则</h1><ol><li>从数据内容来说，<strong>这一列数据越分散越唯一 分布越均匀就越好，越集中取值越少越不好</strong>，比如性别就两个值就不划算</li><li>索引字段是被经常用的，比如被查询，被关联，用的越多，建了索引效果越好，<strong>经常不用的字段没必要建索引</strong></li></ol><h1 id="使用索引时的技巧和注意事项"><a href="#使用索引时的技巧和注意事项" class="headerlink" title="使用索引时的技巧和注意事项"></a>使用索引时的技巧和注意事项</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span>索引不会包含有<span class="hljs-keyword">null</span>值的列<br>只要列中包含有<span class="hljs-keyword">null</span>值都将不会被包含在索引中，复合索引中只要有一列含有<span class="hljs-keyword">null</span>值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为<span class="hljs-keyword">null</span>。<br><span class="hljs-number">2.</span>使用短索引<br>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个<span class="hljs-type">char</span>(<span class="hljs-number">255</span>)的列，如果在前<span class="hljs-number">10</span>个或<span class="hljs-number">20</span>个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。<br><span class="hljs-number">3.</span>索引列排序<br>查询只使用一个索引，因此如果<span class="hljs-keyword">where</span>子句中已经使用了索引的话，那么<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。<br><span class="hljs-number">4.</span><span class="hljs-keyword">like</span>语句操作<br>一般情况下不推荐使用<span class="hljs-keyword">like</span>操作，如果非使用不可，如何使用也是一个问题。<span class="hljs-keyword">like</span>  “%aaa%” 不会使用索引而 <span class="hljs-keyword">like</span> “aaa%” 可以使用索引。<br><span class="hljs-number">5.</span>不要在列上进行运算<br>这将导致索引失效而进行全表扫描，例如<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">WHERE</span> YEAR(<span class="hljs-built_in">column_name</span>)&lt;<span class="hljs-number">2017</span>;<br><span class="hljs-number">6.</span>不使用<span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span>和&lt;&gt;操作<br></code></pre></td></tr></table></figure><h1 id="MySQL索引类型"><a href="#MySQL索引类型" class="headerlink" title="MySQL索引类型"></a>MySQL索引类型</h1><h2 id="物理区分"><a href="#物理区分" class="headerlink" title="物理区分"></a>物理区分</h2><blockquote><p>整个计算机当中的性能瓶颈是 磁盘IO，就是进和出磁盘的速度，也就是IO的读取速度<br>cpu的计算能力，内存速度都不是瓶颈<br>所以找一种数据结构来存储。<br>经过理论和实践，<strong>B+Tree 平衡二叉树</strong> 用起来最优，所以MySQL使用<strong>B+Tree作为索引的结构</strong><br><strong>B+Tree最末端叫叶子节点，叶子节点又分为索引域和data域。</strong><br><strong>根节点和中间的叫非叶子节点</strong></p></blockquote><h4 id="MyISAM存储方式"><a href="#MyISAM存储方式" class="headerlink" title="MyISAM存储方式"></a>MyISAM存储方式</h4><ul><li>MyISAM存储引擎使用B+Tree作为索引结构，叶子节点的data域存放的是数据记录的地址</li><li>MyISAM的索引方式是“非聚集”&lt;索引和数据是分开存储的&gt;的，主索引（primary key）和辅助索引（Secondary key）在结构上没有任何区别，只是主索引key唯一，而辅助索引的key可以重复</li></ul><p><img src="/blog/images/index1.jpg"></p><h4 id="InnoDB-存储引擎"><a href="#InnoDB-存储引擎" class="headerlink" title="InnoDB 存储引擎"></a>InnoDB 存储引擎</h4><ul><li><p>nnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有）。这个索引叫做聚集索引&lt;索引和数据聚集在一块&gt;</p></li><li><p><strong>如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键， 如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形</strong></p></li></ul><blockquote><p>树的深度越深性能越慢；所以在一个节点尽量存多的数据。<br><strong>如何多存：</strong><br>因为根节点的存储空间是一定的，比如16k，64k，所以节点的数占用空间越小，节点数越多，就深度越浅。<br>所以索引取值的字段  越短越好<br><strong>为什么需要主键自增？</strong><br>因为在B+Tree里，当结构定下来后，比如要在20和30之间插入一条25，25后面的数据要重新排序，性能就低；<br>自增的话 不需要在结构上插入，不需要重新排序，性能就高</p></blockquote><p><img src="/blog/images/index2.jpg"></p><ul><li><p>InnoDB的辅助索引data域存储的是相应记录主键的值而不是地址。</p></li><li><p>辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</p></li></ul><p><img src="/blog/images/index3.jpg"></p><h2 id="逻辑区分"><a href="#逻辑区分" class="headerlink" title="逻辑区分"></a>逻辑区分</h2><ul><li>普通索引 ：最基本的索引类型，它没有任何限制，唯一任务就是加快系统对数据的访问速度。 允许在定义索引的列中插入重复值和空值。创建普通索引关键字是 INDEX 或 KEY。</li><li>唯一索引 ：与普通索引类似， 不仅仅可以提高访问速度，还可以避免数据出现重复。唯一索引列或者组合列的值必须唯一，允许有空值。如果是组合索引，则列值的组合必须唯一。创建唯一索引使用 UNIQUE INDEX 关键字。</li><li>主键索引：专门为主键字段创建的索引， 是一种特殊的唯一索引，不允许值重复或者值为空。使用 PRIMARY KEY 关键字。不能使用 CREATE INDEX 语句创建主键索引。</li><li>组合索引：指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀原则。</li><li>全文索引：主要用来查找文本中的关键字，只能在 CHAR、VARCHAR 或 TEXT 类型的列上创建。只有 MyISAM 存储引擎 支持。<ul><li>允许在索引列中插入重复值和空值。使用 FULLTEXT 关键字创建。不过对于大容量的数据表，生成全文索引非常消耗时间和硬盘空间。</li></ul></li><li>空间索引：是对空间数据类型的字段建立的索引，使用 SPATIAL 关键字进行扩展。<ul><li>创建空间索引的列必须将其声明为 NOT NULL，空间索引只能在存储引擎为 MyISAM 的表中创建。</li><li>空间索引主要用于地理空间数据类型 GEOMETRY。对于初学者来说，这类索引很少会用到。</li></ul></li></ul><h1 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h1><h3 id="MySQL创建索引（CREATE-INDEX）"><a href="#MySQL创建索引（CREATE-INDEX）" class="headerlink" title="MySQL创建索引（CREATE INDEX）"></a>MySQL创建索引（CREATE INDEX）</h3><blockquote><p>**CREATE INDEX &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; [&lt;长度&gt;] [ ASC | DESC]) **<br>•&lt;索引名&gt;：指定索引名。一个表可以创建多个索引，但每个索引在该表中的名称是唯一的。<br>•&lt;表名&gt;：指定要创建索引的表名。<br>•&lt;列名&gt;：指定要创建索引的列名。通常可以考虑将查询语句中在 JOIN 子句和 WHERE 子句里经常出现的列作为索引列。<br>•&lt;长度&gt;：可选项。指定使用列的前的几个字符来创建索引，节省索引列所占的空间。•索引列的长度有一个最大上限 255 个字节（MyISAM 和 InnoDB 表的最大上限为 1000 个字节），如果索引列的长度超过了这个上限，就只能用列的前缀进行索引。<br>•BLOB 或 TEXT 类型的列也必须使用前缀索引。<br>•ASC | DESC：可选项。ASC指定索引按照升序来排列，DESC指定索引按照降序来排列，默认为ASC</p></blockquote><p><strong>CREATE TABLE 创建新表的同时创建该表的普通索引:</strong></p><p>KEY | INDEX [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb_stu_info  (<br>     id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>     <span class="hljs-type">name</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>     dept_id <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>     age <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>     height <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>     <span class="hljs-keyword">INDEX</span>(height)      // 如果没有写索引名，默认索引名是字段名<br>     );<br></code></pre></td></tr></table></figure><p><strong>CREATE TABLE 创建新表的同时创建该表的唯一性索引</strong></p><p>UNIQUE [ INDEX | KEY] [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb_stu_info2  (<br>     id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>     <span class="hljs-type">name</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>     dept_id <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>     age <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>     height <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>     <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">INDEX</span>(height)     // 如果没有写索引名，默认索引名是字段名<br>     );<br></code></pre></td></tr></table></figure><p><strong>ALTER TABLE 修改表时 添加唯一索引或者索引</strong></p><p>ADD UNIQUE|INDEX [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//在 tb_student 表中的 id 字段上建立名为 index_id 的索引。<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> index_id <span class="hljs-keyword">ON</span> tb_student(id);<br><br>//在 tb_student 表中的 id 字段上建立名为 index_id 的索引，<span class="hljs-keyword">SQL</span> 语句如下：<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">INDEX</span> index_id <span class="hljs-keyword">ON</span> tb_student(id);<br>#其中，id 字段可以有唯一性约束，也可以没有。<br><br>//在 tb_student 表中的 <span class="hljs-keyword">info</span> 字段上建立名为 index_info 的全文索引，<span class="hljs-keyword">SQL</span> 语句如下：<br><span class="hljs-keyword">CREATE</span> FULLTEXT <span class="hljs-keyword">INDEX</span> index_info <span class="hljs-keyword">ON</span> tb_student(<span class="hljs-keyword">info</span>);<br></code></pre></td></tr></table></figure><h3 id="MySQL删除索引（DROP-INDEX）"><a href="#MySQL删除索引（DROP-INDEX）" class="headerlink" title="MySQL删除索引（DROP INDEX）"></a>MySQL删除索引（DROP INDEX）</h3><blockquote><ol><li><p>DROP INDEX &lt;索引名&gt; ON &lt;表名&gt;<br>•&lt;索引名&gt;：要删除的索引名。<br>•&lt;表名&gt;：指定该索引所在的表名。</p></li><li><p>ALTER TABLE 语句的语法中部分指定为以下子句中的某一项。<br>•DROP PRIMARY KEY：表示删除表中的主键。一个表只有一个主键，主键也是一个索引。<br>•DROP INDEX index_name：表示删除名称为 index_name 的索引。<br>•DROP FOREIGN KEY fk_symbol：表示删除外</p></li></ol></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> height <span class="hljs-keyword">ON</span> tb_stu_info;  // height是索引的名称，如果没有写索引名称，默认就是字段名称<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_stu_info2 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> height;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">#索引类型<br># #### <span class="hljs-number">1.</span>普通索引<br>#是最基本的索引，它没有任何限制。它有以下几种创建方式：<br><br>#（<span class="hljs-number">1</span>）直接创建索引<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> index_name <span class="hljs-keyword">ON</span> <span class="hljs-keyword">table</span>(<span class="hljs-keyword">column</span>(length))<br> ##<span class="hljs-number">2</span>）修改表结构的方式添加索引<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> index_name <span class="hljs-keyword">ON</span> (<span class="hljs-keyword">column</span>(length))<br> ##<span class="hljs-number">3</span>）创建表的时候同时创建索引<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">table</span>` (<br>    `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT ,<br>    `title` <span class="hljs-type">char</span>(<span class="hljs-number">255</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> ,<br>    `content` <span class="hljs-type">text</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">NULL</span> ,<br>    `<span class="hljs-type">time</span>` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> ,<br>    <span class="hljs-keyword">PRIMARY KEY</span> (`id`),<br>    <span class="hljs-keyword">INDEX</span> index_name (title(length))<br>)<br>#（<span class="hljs-number">4</span>）删除索引<br><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> index_name <span class="hljs-keyword">ON</span> <span class="hljs-keyword">table</span><br><span class="hljs-meta">#2.唯一索引</span><br>#与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：<br>#（<span class="hljs-number">1</span>）创建唯一索引<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">INDEX</span> indexName <span class="hljs-keyword">ON</span> <span class="hljs-keyword">table</span>(<span class="hljs-keyword">column</span>(length))<br>#（<span class="hljs-number">2</span>）修改表结构<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> indexName <span class="hljs-keyword">ON</span> (<span class="hljs-keyword">column</span>(length))<br>#（<span class="hljs-number">3</span>）创建表的时候直接指定<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">table</span>` (<br>    `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT ,<br>    `title` <span class="hljs-type">char</span>(<span class="hljs-number">255</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> ,<br>    `content` <span class="hljs-type">text</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">NULL</span> ,<br>    `<span class="hljs-type">time</span>` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> ,<br>    <span class="hljs-keyword">UNIQUE</span> indexName (title(length))<br>);<br><span class="hljs-meta">#3.主键索引</span><br>#是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引：<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">table</span>` (<br>    `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT ,<br>    `title` <span class="hljs-type">char</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> ,<br>    <span class="hljs-keyword">PRIMARY KEY</span> (`id`)<br>);<br><span class="hljs-meta">#4.组合索引</span><br>#指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">table</span>` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> name_city_age (<span class="hljs-type">name</span>,city,age);<br><span class="hljs-meta">#5.全文索引</span><br><br>#主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的<span class="hljs-keyword">where</span>语句的参数匹配。<br># fulltext索引配合match against操作使用，而不是一般的<span class="hljs-keyword">where</span>语句加<span class="hljs-keyword">like</span>。它可以在<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span>，<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> ，<span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span>使用，不过目前只有<span class="hljs-type">char</span>、<span class="hljs-type">varchar</span>，<span class="hljs-type">text</span> 列上可以创建全文索引。<br># 值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">index</span>创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。<br><br>#（<span class="hljs-number">1</span>）创建表的适合添加全文索引<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">table</span>` (<br>    `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT ,<br>    `title` <span class="hljs-type">char</span>(<span class="hljs-number">255</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> ,<br>    `content` <span class="hljs-type">text</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">NULL</span> ,<br>    `<span class="hljs-type">time</span>` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> ,<br>    <span class="hljs-keyword">PRIMARY KEY</span> (`id`),<br>    FULLTEXT (content)<br>);<br>#（<span class="hljs-number">2</span>）修改表结构添加全文索引<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> article <span class="hljs-keyword">ADD</span> FULLTEXT index_content(content)<br># （<span class="hljs-number">3</span>）直接创建索引<br><span class="hljs-keyword">CREATE</span> FULLTEXT <span class="hljs-keyword">INDEX</span> index_content <span class="hljs-keyword">ON</span> article(content)<br></code></pre></td></tr></table></figure><h1 id="MySQL-索引失效"><a href="#MySQL-索引失效" class="headerlink" title="MySQL 索引失效"></a>MySQL 索引失效</h1><h3 id="失效的场景"><a href="#失效的场景" class="headerlink" title="失效的场景"></a>失效的场景</h3><blockquote><p>没有查询条件，或者查询条件没有建立索引;<br>在查询条件上没有使用引导列，<strong>最左前缀规则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用</strong>&lt;比如组合索引：在where子句里用的时候，就必须从第一个字段来限制才管用，比如用第一和第二个索引来查询；如果不用第一个索引，直接开始用第二个索引，索引就失效&gt;<br>查询的数量是大表的大部分，应该是30％以上。<br>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引<br>索引本身失效，即没有建立索引成功<br>在索引列上使用函数、计算、类型转换<br>对小表查询<br>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。<br>如果like是以%开始<br> 使用NOT IN和&lt;&gt;操作<br>DATE_FORMAT()格式化时间，格式化后的时间再去比较，可能会导致索引失效。</p></blockquote><h3 id="MySQL-EXPLAIN和DESCRIBE（查询分析器）"><a href="#MySQL-EXPLAIN和DESCRIBE（查询分析器）" class="headerlink" title="MySQL EXPLAIN和DESCRIBE（查询分析器）"></a>MySQL EXPLAIN和DESCRIBE（查询分析器）</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> stud_id=<span class="hljs-string">&#x27;1&#x27;</span>  <span class="hljs-keyword">or</span> phone=<span class="hljs-string">&#x27;18729902095&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><p>id ：表示 SELECT 语句的编号</p></li><li><p>select_type ：该参数有以下几个常用的取值：</p></li></ul><blockquote><p>• SIMPLE：表示简单查询，其中不包括连接查询和子查询；<br>• PRIMARY：表示主查询，或者是最外层的查询语句；<br>• UNION：表示连接查询的第二个或后面的查询语句；<br>• DEPENDENT UNION：连接查询中的第 2 个或后面的 SELECT 语句，取决于外面的查询；<br>• UNION RESULT：连接查询的结果；<br>• SUBQUERY：子查询中的第 1 个 SELECT 语句；<br>• DEPENDENT SUBQUERY：子查询中的第 1 个 SELECT 语句，取决于外面的查询；<br>• DERIVED：导出表的 SELECT（FROM 子句的子查询）。</p></blockquote><ul><li><p>table ： 表示查询的表</p></li><li><p>type ：表示表的连接类型。该参数有以下几个常用的取值，范围从 NULL 到 ALL。下面按照最佳类型到最差类型排序：</p></li></ul><blockquote><p>NULL：不用访问表或者索引，直接就能得到结果；<br>system：表示表中只有一条记录；<br>const：表示表中有多条记录，但只从表中查询一条记录；<br>eq _ref：类似 ref，表示多表连接时，后面的表使用了 UNIQUE 或者 PRIMARY KEY；<br>ref：表示多表查询时，后面的表使用了普通索引；<br>range：表示查询语句中给出了查询范围，常见于 &lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;、between 等操作符；<br>index：表示对表中的索引进行了完整的扫描，MySQL 遍历整个索引来查询匹配的行；<br>ALL：表示对表进行了完整的扫描，MySQL 遍历全表来找到匹配的行</p></blockquote><ul><li><p>possible_keys ：表示查询中可以使用的索引，可能用到这个索引；</p></li><li><p>key ：表示实际查询中使用到的索引，为NULL表示最终没有用到索引；</p></li><li><p>key_len ：表示索引字段的长度；</p></li><li><p>ref ： 表示使用哪个列或常数与索引一起来查询记录；</p></li><li><p>rows： 表示查询的行数；</p></li><li><p>filtered ：表示存储引擎返回的数据在 server 层过滤后，剩下多少满足查询记录数量的比例。注意是百分比，不是具体记录数。</p></li><li><p>Extra ：表示查询过程的附件信息。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户管理</title>
    <link href="/blog/2018/05/29/linux/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <url>/blog/2018/05/29/linux/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a><strong>创建用户</strong></h3><ol><li><p>useradd -m -g 组 用户名：创建用户</p></li><li><p>-m 会自动创建用户家目录</p></li><li><p>-g 会指定用户所在组，否认会创建一个用户同名的组</p></li><li><p>passwd 用户名：创建用户密码</p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">useradd -m -<span class="hljs-selector-tag">g</span> lgw leegw<br>passwd leegw<br>更改用户 leegw 的密码 <br><span class="hljs-number">1</span>、密码少于 <span class="hljs-number">8</span> 个字符<br><span class="hljs-number">2</span>、密码不能包含用户名<br><span class="hljs-number">3</span>、一次命令允许连续输入<span class="hljs-number">4</span>次，否则，超出服务重试的最多次数<br></code></pre></td></tr></table></figure><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a><strong>删除用户</strong></h3><ol><li>userdel -r 用户名；-r选项会自动删除用户家目录</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><br><span class="hljs-attribute">userdel</span> leegw<br><span class="hljs-attribute">userdel</span> -r leegw   # 同步删除 家目录<br><span class="hljs-attribute">userdel</span>: user ligw is currently used by process <span class="hljs-number">15288</span><br><span class="hljs-attribute">ps</span> -ef |grep <span class="hljs-number">15288</span><br><span class="hljs-attribute">kill</span> - <span class="hljs-number">9</span> <span class="hljs-number">15288</span><br></code></pre></td></tr></table></figure><h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><ol><li><p>id [用户名] 查看用户 UID 和 GID 信息</p></li><li><p>who 查看当前所有登录的用户列表</p></li><li><p>whoami 查看当前登录用户的账户名</p></li><li><p>&#x2F;etc&#x2F;passwd 文件存放的是用户的信息，由 6 个分号组成的 7 个信息，分别是</p></li><li><p>•用户名</p></li><li><p>•密码（x，表示加密的密码）</p></li><li><p>•UID（用户标识）</p></li><li><p>•GID（组标识）</p></li><li><p>•用户全名或本地帐号</p></li><li><p>•家目录</p></li><li><p>•登录使用的 Shell，就是登录之后，使用的终端命令，ubuntu 默认是 dash</p></li><li><p>cat &#x2F;etc&#x2F;passwd  #查看所有用户信息</p></li></ol><h3 id="修改用户usermod"><a href="#修改用户usermod" class="headerlink" title="修改用户usermod"></a>修改用户usermod</h3><p>usermod 可以用来设置 用户 的 主组 ／ 附加组 和 登录 Shell，命令格式如下：</p><ul><li><p>主组：通常在新建用户时指定，在 etc&#x2F;passwd 的第 4 列 GID 对应的组</p></li><li><p>附加组：在 etc&#x2F;group 中最后一列表示该组的用户列表，用于指定 用户的附加权限</p></li><li><p>提示：设置了用户的附加组之后，需要重新登录才能生效！</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">usermod -g 组 用户名 <span class="hljs-comment"># 修改用户的主组（passwd 中的 GID）</span><br>usermod -G 组 用户名 <span class="hljs-comment"># 修改用户的附加组</span><br>usermod -s <span class="hljs-regexp">/bin/</span>bash 用户名 <span class="hljs-comment"># 修改用户登录 Shell</span><br></code></pre></td></tr></table></figure><p><strong>创建用户 &#x2F; 删除用户 &#x2F; 修改其他用户密码 的终端命令都需要通过 su</strong></p><h3 id="管理用户组"><a href="#管理用户组" class="headerlink" title="管理用户组"></a><strong>管理用户组</strong></h3><blockquote><p>groupadd 组名 #添加组<br>groupdel 组名 #删除组<br>cat &#x2F;etc&#x2F;group #确认组信息<br>groupmod 选项 用户组 # 修改组</p></blockquote><h3 id="root用户"><a href="#root用户" class="headerlink" title="root用户"></a><strong>root用户</strong></h3><p>root 账号通常 用于系统的维护和管理，对操作系统的所有资源 具有所有访问权限</p><p>不推荐 直接使用 root 账号登录系统</p><p>在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户”</p><p>sudo</p><p>•su 是 substitute user 的缩写，表示 使用另一个用户的身份</p><p>•sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具</p><p>•sudo 命令用来以其他身份来执行命令，预设的身份为 root </p><p>•用户使用 sudo 时，必须先输入密码，之后有 5 分钟的有效期限，超过期限则必须重新输入密码</p><p>• 若其未经授权的用户企图使用 sudo，则会发出警告邮件给管理</p><h6 id="设置普通用户的sudo无密码登录权限"><a href="#设置普通用户的sudo无密码登录权限" class="headerlink" title="设置普通用户的sudo无密码登录权限"></a><strong>设置普通用户的sudo无密码登录权限</strong></h6><blockquote><p>1.** <strong><strong># vi &#x2F;etc&#x2F;sudoers</strong><br>2.在第一行编辑：**用户名 ALL&#x3D;(root)NOPASSWD:ALL</strong><br>eg：  baby ALL&#x3D;(root)NOPASSWD:ALL</p></blockquote><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a><strong>切换用户</strong></h3><ol><li><p>su - 用户名：切换用户，并且切换到家目录；不加-，则不会切换到家目录，保持原来路径不变</p></li><li><p>su 不接用户名，可以切换到 root，但是不推荐使用，因为不安全</p></li><li><p>su - 用户名：切换到新用户</p></li><li><p>su：切换到管理员</p></li></ol><blockquote><p>1.root用户切换到普通用户，不需要密码<br>2.普通用户切换到root用户，需要密码</p></blockquote><h3 id="修改用户的文件权限"><a href="#修改用户的文件权限" class="headerlink" title="修改用户的文件权限"></a>修改用户的文件权限</h3><ol><li><p>chmod：设置文件对不同用户的权限，需要使用root用户</p></li><li><p>chgrp：修改组</p></li><li><p>chown：修改拥有者</p></li></ol><blockquote><p>chown 用户名 文件名|目录名 # 修改文件|目录的拥有者<br>chgrp -R 组名 文件名|目录名 # 递归修改文件|目录的组<br>chmod -R 755 文件名|目录名 # 递归修改文件权限<br>chmod 在设置权限时，可以简单地使用三个数字分别对应拥有者／ 组和其他用户的权限<br>直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他<br>chmod +&#x2F;-rwx 文件名|目录名 # 一次性修改 拥有者 &#x2F; 组 权限</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># chmod</span><br>eg: -rw-rw-r--. 1 baby baby 0 May 31 16:02 a.py<br>需求：对于同组用户来说，仅仅可读，对于其他用户不可读不可写<br>    权限字符形式操作：<br>        <span class="hljs-comment"># chmod  g-w a.py      (表示对于同组u用户，删除可写权限)</span><br>        <span class="hljs-comment"># chmod  o-r a.py    (表示对于其他用户，删除读和写权限)</span><br>        <span class="hljs-comment"># chmod g-r-w a.py  (表示对于同组用户，删除读和写权限)</span><br>    <br>    权限数字形式权限：<br>        <span class="hljs-comment"># chmod 664  (表示对拥有着可读可写，同组用户可读可写，其他用户可读)</span><br><br>    问题：如果针对一个目录，设置权限呢？且目录中有许多文件，这些文件都需要同样的权限设置。<br>        -R, --recursive  递归<br>        <span class="hljs-comment"># chmod -R 664 /opt/softwares</span><br><br><span class="hljs-comment"># chown</span><br>    <span class="hljs-built_in">chown</span> baby /home/a.py<br><span class="hljs-comment"># chgrp</span><br>    <span class="hljs-built_in">chgrp</span> baby /home/a.py<br>    经测，两个命令都要运行，才会改变(不一定)<br><span class="hljs-comment"># 如果针对目录：递归</span><br>    <span class="hljs-built_in">chown</span> -R baby /opt/softwares<br>    <span class="hljs-built_in">chgrp</span> -R baby /opt/softwares<br><span class="hljs-comment"># 将/home/a.py文件的所属用户和所属组改为senior用户和senior组</span><br>    可以使用一个命令完成：<br>    <span class="hljs-built_in">chown</span> senior:senior /home/a.py<br>    senior:senior: 第一个senior代表用户，第二个senior代表组<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统管理</title>
    <link href="/blog/2018/05/23/linux/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    <url>/blog/2018/05/23/linux/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">/etc/profile：配置全局环境变量，所有用户都可以用<br>用户家目录/.bash_profile 配置环境变量，只对当前用户生效<br>文件的path环境变量中多个配置用:分开，最后加上. 代表当前路径下文件可直接调用，而不需要加上./<br>比如配置jdk<br>     <span class="hljs-built_in">export</span>    <span class="hljs-attribute">JAVA_HOME</span>=/opt/jdk1.8.0_281<br>     <span class="hljs-built_in">export</span>    <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$JAVA_HOME</span>/bin:$PATH:.<br></code></pre></td></tr></table></figure><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><ol><li>top：动态显示运行中的进程并且排序</li><li>ps <ol><li>ps aux：查看进程的详细状况<ol><li>a 显示终端上的所有进程，包括其他用户的进程</li><li>u 显示进程的详细状态</li><li>x 显示没有控制终端的进程</li></ol></li><li>ps -ef</li></ol></li></ol><h4 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h4><ol><li>kill：kill [-9] 进程代号 终止指定代号的进程，-9 表示强行终止 </li><li>pkill：按照进程名杀死进程。pkill java：杀掉所有java进程；是按照进程名称来杀死进程 </li><li>提示： 使用 kill 命令时，最好只终止由当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃要退出 </li><li>批量删除进程:  kill -9 <code>ps -ef | grep *** | awk &#39;&#123;print $2&#125;&#39;</code></li><li>批量kill：ps auxww | grep ‘gunicorn’ | awk ‘{print $2}’ | xargs kill -9 </li><li>以树状图形式查看pid号，杀掉主进程，所有进程都杀掉：pstree -ap | grep gunicorn<br><img src="/blog/images/mysql&linux/1722580916435.png"></li></ol><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><h4 id="方式1：service-–-7-3版本之前"><a href="#方式1：service-–-7-3版本之前" class="headerlink" title="方式1：service – 7.3版本之前"></a>方式1：service – 7.3版本之前</h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-number">1</span>.查看防火墙的状态<br>[baby<span class="hljs-variable">@localhost</span> etc]<span class="hljs-variable">$ </span>sudo service iptables status<br><span class="hljs-symbol">iptables:</span> Firewall is not running.<br><br><span class="hljs-number">2</span>.关闭防火墙：<br>[baby<span class="hljs-variable">@localhost</span> etc]<span class="hljs-variable">$ </span>sudo service iptables stop<br><br><span class="hljs-number">3</span>.启动防火墙：<br>[baby<span class="hljs-variable">@localhost</span> etc]<span class="hljs-variable">$ </span>sudo service iptables start<br><br><span class="hljs-number">4</span>.重启防火墙：<br>[baby<span class="hljs-variable">@localhost</span> etc]<span class="hljs-variable">$ </span>sudo service iptables restart<br><br><span class="hljs-number">5</span>.永久性设置防火墙关闭|开启(意思就是设置开启启动|关闭防火墙)：<br><span class="hljs-variable">$ </span>sudo chkconfig iptables off|on<br></code></pre></td></tr></table></figure><h4 id="方式2：systemctl-–-7-3版本之后"><a href="#方式2：systemctl-–-7-3版本之后" class="headerlink" title="方式2：systemctl – 7.3版本之后"></a>方式2：systemctl – 7.3版本之后</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">查看防火墙状态：firewall-cmd <span class="hljs-attr">--state</span><br>关闭防火墙：systemctl <span class="hljs-selector-tag">stop</span> firewalld<span class="hljs-selector-class">.service</span><br>禁止防火墙开机启动：systemctl disable firewalld.service<br></code></pre></td></tr></table></figure><h4 id="防火墙2-SELINUX-禁用"><a href="#防火墙2-SELINUX-禁用" class="headerlink" title="防火墙2-SELINUX 禁用"></a>防火墙2-SELINUX 禁用</h4><ol><li><p>第一步：编辑</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">vi  /etc/sysconfig/selinux<br><span class="hljs-attribute">SELINUX</span>=disabled<br>或者：<br>vi /etc/selinux<span class="hljs-built_in">/config</span><br><span class="hljs-built_in"></span><span class="hljs-attribute">SELINUX</span>=disabled<br>注意：不能改错，要不然重启不了服务器<br></code></pre></td></tr></table></figure></li><li><p>第二步重启服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> reboot<br></code></pre></td></tr></table></figure></li></ol><h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ruby">- 查看什么系统<br>[baby<span class="hljs-variable">@localhost</span> ~]<span class="hljs-variable">$ </span>uname  <br><span class="hljs-title class_">Linux</span><br>- 可显示电脑以及操作系统的相关信息。<br>uname -a <br>- 查看内核版本<br>[baby<span class="hljs-variable">@localhost</span> ~]<span class="hljs-variable">$ </span>uname -r    <br><span class="hljs-number">2.6</span>.<span class="hljs-number">32</span>-<span class="hljs-number">358</span>.el6.x86_64<br>- 查看cpu信息<br>[baby<span class="hljs-variable">@localhost</span> ~]<span class="hljs-variable">$ </span>cat /<span class="hljs-built_in">proc</span>/cpuinfo   <br>- 查看内存信息<br>[baby<span class="hljs-variable">@localhost</span> ~]<span class="hljs-variable">$ </span>cat /<span class="hljs-built_in">proc</span>/meminfo   <br><br>cat /<span class="hljs-built_in">proc</span>/version<span class="hljs-string">&quot;,说明正在运行的内核版本。  </span><br><span class="hljs-string">cat /etc/issue&quot;</span>, 显示的是发行版本信息<br></code></pre></td></tr></table></figure><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><ul><li>查看剩余磁盘空间：df<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tcl">-a ：列出所有的文件系统，包括系统特有的 /<span class="hljs-keyword">proc</span> 等文件系统；<br>-k ：以<span class="hljs-title"> KBytes</span> 的容量显示各文件系统；<br>-m ：以<span class="hljs-title"> MBytes</span> 的容量显示各文件系统；<br>-h ：以人们较易阅读的<span class="hljs-title"> GBytes,</span> MBytes,<span class="hljs-title"> KBytes</span> 等格式自行显示；<br>-H ：以<span class="hljs-title"> M=1000K</span> 取代<span class="hljs-title"> M=1024K</span> 的进位方式；<br>-T ：显示文件系统类型, 连同该<span class="hljs-title"> partition</span> 的<span class="hljs-title"> filesystem</span> 名称 (例如<span class="hljs-title"> ext3)</span> 也列出；<br>-i ：不用硬盘容量，而以<span class="hljs-title"> inode</span> 的数量来显示<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -h: 易读方式打印<br><span class="hljs-built_in">df</span> -lh<br><br><span class="hljs-built_in">df</span> -aT       <span class="hljs-comment">#将系统内的所有特殊文件格式及名称都列出来</span><br><span class="hljs-built_in">df</span> -h /etc   <span class="hljs-comment">#将 /etc 底下的可用的磁盘容量以易读的容量格式显示</span><br><span class="hljs-built_in">df</span> -hi: 打印inode。操作系统的文件由两部分组成，数据部分和名称部分；数据部分就是内容，inode就是名称部分，操作系统对文件的个数和容量都有上限，其中一个满了就会不可写；<br><br></code></pre></td></tr></table></figure><ul><li>显示目录下文件大小：du<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">显示目录下的文件大小。 检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。<br><span class="hljs-built_in">du</span> -sh /home/baby     预估在某个路径下使用的磁盘空间大小<br><span class="hljs-built_in">du</span> -sm /*    <span class="hljs-comment">#检查根目录底下每个目录所占用的容量</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h2><ul><li>看系统内存使用情况 free<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@localhost baby]<span class="hljs-comment"># free -m</span><br>             total       used       free     shared    buffers     cached<br>Mem:          <span class="hljs-number"> 995 </span>      <span class="hljs-number"> 884 </span>      <span class="hljs-number"> 110 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 149 </span>       385<br>-/+ buffers/cache:       <span class="hljs-number"> 349 </span>       646<br>Swap:        <span class="hljs-number"> 4095 </span>        <span class="hljs-number"> 0 </span>      4095<br></code></pre></td></tr></table></figure></li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ol><li>监控TCP&#x2F;IP网络端口<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">netstat是控制台命令,是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设<br>备的状态信息。Netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。<br><br><span class="hljs-section">常用netstat相关命令:</span><br>1、列出所有端口 <span class="hljs-comment">#netstat -a</span><br>2、列出所有 tcp 端口 <span class="hljs-comment">#netstat -at</span><br>3、列出所有 udp 端口 <span class="hljs-comment">#netstat -au</span><br>4、只显示监听端口 <span class="hljs-comment">#netstat -l</span><br>5、只列出所有监听 tcp 端口 <span class="hljs-comment">#netstat -lt</span><br>6、只列出所有监听 udp 端口 <span class="hljs-comment">#netstat -lu</span><br>7、列出所有监听 UNIX 端口 <span class="hljs-comment">#netstat -lx</span><br>8、显示所有端口的统计信息 <span class="hljs-comment">#netstat -s</span><br></code></pre></td></tr></table></figure></li><li>查看网卡的信息<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[root@localhost baby]# cd /etc/sysconfig/network-scripts <br>[root@localhost network-scripts]# ls<br>ifcfg-eth0   ifdown-isdn    ifup-aliases  ifup-plusb     init.ipv6-global<br>ifcfg-lo     ifdown-post    ifup-bnep     ifup-post      net.hotplug<br>ifdown       ifdown-ppp     ifup-eth      ifup-ppp       network-functions<br>ifdown-bnep  ifdown-routes  ifup-ippp     ifup-routes    network-functions-ipv6<br>ifdown-eth   ifdown-sit     ifup-ipv6     ifup-sit<br>ifdown-ippp  ifdown-tunnel  ifup-isdn     ifup-tunnel<br>ifdown-ipv6  ifup           ifup-plip     ifup-wireless<br>[root@localhost network-scripts]# cat ifcfg-eth0 <br><span class="hljs-attribute">DEVICE</span>=eth0<br><span class="hljs-attribute">TYPE</span>=Ethernet<br><span class="hljs-attribute">UUID</span>=57d4c2c9-9e9c-48f8-a654-8e5bdbadafb8<br><span class="hljs-attribute">ONBOOT</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attribute">NM_CONTROLLED</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attribute">BOOTPROTO</span>=none<br><span class="hljs-attribute">DEFROUTE</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attribute">IPV4_FAILURE_FATAL</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attribute">IPV6INIT</span>=<span class="hljs-literal">no</span><br><span class="hljs-attribute">NAME</span>=<span class="hljs-string">&quot;System eth0&quot;</span><br><span class="hljs-attribute">HWADDR</span>=00:0C:29:CD:79:8C<br><span class="hljs-attribute">IPADDR</span>=192.168.202.110<br><span class="hljs-attribute">PREFIX</span>=24<br><span class="hljs-attribute">GATEWAY</span>=192.168.202.110<br><span class="hljs-attribute">LAST_CONNECT</span>=1559242361<br>[root@localhost network-scripts]# cat ifcfg-lo<br><span class="hljs-attribute">DEVICE</span>=lo<br><span class="hljs-attribute">IPADDR</span>=127.0.0.1<br><span class="hljs-attribute">NETMASK</span>=255.0.0.0<br><span class="hljs-attribute">NETWORK</span>=127.0.0.0<br><span class="hljs-comment"># If you&#x27;re having problems with gated making 127.0.0.0/8 a martian,</span><br><span class="hljs-comment"># you can change this to something else (255.255.255.255, for example)</span><br><span class="hljs-attribute">BROADCAST</span>=127.255.255.255<br><span class="hljs-attribute">ONBOOT</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attribute">NAME</span>=loopback<br></code></pre></td></tr></table></figure></li></ol><h2 id="关机重启"><a href="#关机重启" class="headerlink" title="关机重启"></a>关机重启</h2><ol><li>shutdown 命令可以 安全 关闭 或者 重新启动系统<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">选项 -r 重新启动</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">提示：</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">•不指定选项和参数，默认表示 <span class="hljs-number">1</span> 分钟之后 关闭电脑</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">•远程维护服务器时，最好不要关闭系统，而应该重新启动系统</span><br></code></pre></td></tr></table></figure></li></ol><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$ <span class="hljs-built_in">shutdown</span> -r now <span class="hljs-meta"># 重新启动操作系统，其中 now 表示现在</span><br>$ <span class="hljs-built_in">shutdown</span> now <span class="hljs-meta"># 立刻关机，其中 now 表示现在</span><br>$ <span class="hljs-built_in">shutdown</span> <span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-meta"># 系统在今天的 20:25 会关机</span><br>$ <span class="hljs-built_in">shutdown</span> +<span class="hljs-number">10</span> <span class="hljs-meta"># 系统再过十分钟后自动关机</span><br>$ <span class="hljs-built_in">shutdown</span> -c <span class="hljs-meta"># 取消之前指定的关机计</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li>halt 关机</li><li>reboot 重启</li></ol><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><ul><li><p><strong>显示当前的日期</strong></p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[baby@localhost ~]$** date**     </span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Sun</span> <span class="hljs-title class_">Jun</span>  <span class="hljs-number">9</span> <span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">58</span> <span class="hljs-variable constant_">EDT</span> <span class="hljs-number">2019</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[baby@localhost ~]$ **date -R  **  显示当前的日期和时区</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Sun</span>, <span class="hljs-number">09</span> <span class="hljs-title class_">Jun</span> <span class="hljs-number">2019</span> <span class="hljs-number">13</span>:<span class="hljs-number">53</span>:<span class="hljs-number">03</span> -<span class="hljs-number">0400</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>设置时间（需要root用户）</strong></p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[root@localhost baby]# **date -s <span class="hljs-number">2019</span>-<span class="hljs-number">06</span>-<span class="hljs-number">10</span>**</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Mon</span> <span class="hljs-title class_">Jun</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-variable constant_">EDT</span> <span class="hljs-number">2019</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[root@localhost baby]# **date -s <span class="hljs-number">14</span>:<span class="hljs-number">42</span>:<span class="hljs-number">10</span>**</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Mon</span> <span class="hljs-title class_">Jun</span> <span class="hljs-number">10</span> <span class="hljs-number">14</span>:<span class="hljs-number">42</span>:<span class="hljs-number">10</span> <span class="hljs-variable constant_">EDT</span> <span class="hljs-number">2019</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[root@localhost baby]# date</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Mon</span> <span class="hljs-title class_">Jun</span> <span class="hljs-number">10</span> <span class="hljs-number">14</span>:<span class="hljs-number">42</span>:<span class="hljs-number">11</span> <span class="hljs-variable constant_">EDT</span> <span class="hljs-number">2019</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>显示2015年的日历表</strong></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">&gt; [baby<span class="hljs-variable">@localhost</span> ~]<span class="hljs-variable">$ </span>**cal <span class="hljs-number">2015</span>   **<br></code></pre></td></tr></table></figure></li></ul><h2 id="crontab定时调度"><a href="#crontab定时调度" class="headerlink" title="crontab定时调度"></a>crontab定时调度</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>crontab命令用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。</li><li>cron 系统调度进程。 可以使用它在每天的非高峰负荷时间段运行作业，或在一周或一月中的不同时段运行。cron是系统主要的调度进程，可以在无需人工干预的情况下运行作业。crontab命令允许用户提交、编辑或删除相应的作业。每一个用户都可以有一个crontab文件来保存调度信息。系统管理员可以通过cron.deny 和 cron.allow 这两个文件来禁止或允许用户拥有自己的crontab文件。</li><li>名词解释： cron是服务名称，crond是后台进程，crontab则是定制好的计划任务表。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p>要使用cron服务，先要安装vixie-cron软件包和crontabs软件包，两个软件包作用如下： </p><ol><li><p>vixie-cron软件包是cron的主程序。</p></li><li><p>crontabs软件包是用来安装、卸装、或列举用来驱动 cron 守护进程的表格的程序。</p></li></ol></li><li><p>查看是否安装 </p><ol><li>查看是否安装了cron软件包: rpm -qa|grep vixie-cron</li><li>查看是否安装了crontabs软件包:rpm -qa|grep crontabs</li></ol></li><li><p>软件包存在如何安装</p><ol><li>如果没有安装，则执行如下命令安装软件包(软件包必须存在)<blockquote><p>rpm -ivh vixie-cron-4.1-54.FC5*<br>rpm -ivh crontabs*</p></blockquote></li></ol></li><li><p>安装包不存在如何安装(正常情况下都是这样安装方式)</p></li></ol><ul><li>如果本地没有安装包，在能够连网的情况下可以在线安装<blockquote><p>yum install vixie-cron或者yum -y install vixie-cron<br>yum install crontabs或者yum -y install crontabs</p></blockquote></li></ul><ol start="5"><li>查看crond服务状态：<blockquote><p>pgrep crond或&#x2F;sbin&#x2F;service crond status或ps -elf|grep crond|grep -v “grep”</p></blockquote></li></ol><p>###配置<br>crond服务操作命令:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">service </span><span class="hljs-title class_">crond</span> start     <span class="hljs-comment">//启动服务</span><br><span class="hljs-keyword">service </span><span class="hljs-title class_">crond</span> stop      <span class="hljs-comment">//关闭服务</span><br><span class="hljs-keyword">service </span><span class="hljs-title class_">crond</span> restart   <span class="hljs-comment">//重启服务</span><br><span class="hljs-keyword">service </span><span class="hljs-title class_">crond</span> reload    <span class="hljs-comment">//重新载入配置</span><br><span class="hljs-keyword">service </span><span class="hljs-title class_">crond</span> status    <span class="hljs-comment">//查看crontab服务状态</span><br>或这种形式<br>/sbin/<span class="hljs-keyword">service </span><span class="hljs-title class_">crond</span> start<span class="hljs-comment">//启动服务 </span><br>/sbin/<span class="hljs-keyword">service </span><span class="hljs-title class_">crond</span> stop<span class="hljs-comment">//关闭服务 </span><br>/sbin/<span class="hljs-keyword">service </span><span class="hljs-title class_">crond</span> restart<span class="hljs-comment">//重启服务 </span><br>/sbin/<span class="hljs-keyword">service </span><span class="hljs-title class_">crond</span> reload<span class="hljs-comment">//重新载入配置</span><br></code></pre></td></tr></table></figure><p>在CentOS系统中设置cron开机自动启动: chkconfig –level 345 crond on</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>crontab(选项)(参数)<br>选项<br>-e：编辑该用户的计时器设置；<br>-l：列出该用户的计时器设置；<br>-r：删除该用户的计时器设置；<br>-u&lt;用户名称&gt;：指定要设定计时器的用户名称。<br>-i：在删除用户的crontab文件时给确认提示<br>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。 如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</p><h3 id="加入定时任务"><a href="#加入定时任务" class="headerlink" title="加入定时任务"></a>加入定时任务</h3><p><img src="/blog/images/mysql&linux/20972_0.png"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs swift">时间间隔的单位可以是分钟<span class="hljs-operator">、</span>小时<span class="hljs-operator">、</span>日<span class="hljs-operator">、</span>月<span class="hljs-operator">、</span>周及以上的任意组合<span class="hljs-operator">。</span>这个命令非常设合周期性的日志分析或数据备份等工作<span class="hljs-operator">。</span><br><br>crontab任务配置基本格式：<br><span class="hljs-operator">*</span> <span class="hljs-operator">*</span>　 <span class="hljs-operator">*</span>　 <span class="hljs-operator">*</span>　 <span class="hljs-operator">*</span>　　command<br>分钟(<span class="hljs-number">0</span><span class="hljs-operator">-</span><span class="hljs-number">59</span>)　小时(<span class="hljs-number">0</span><span class="hljs-operator">-</span><span class="hljs-number">23</span>)　日期(<span class="hljs-number">1</span><span class="hljs-operator">-</span><span class="hljs-number">31</span>)　月份(<span class="hljs-number">1</span><span class="hljs-operator">-</span><span class="hljs-number">12</span>)　星期(<span class="hljs-number">0</span><span class="hljs-operator">-</span><span class="hljs-number">6</span>,<span class="hljs-number">0</span>代表星期天)　 命令<br><br>第<span class="hljs-number">1</span>列表示分钟<span class="hljs-number">1</span>～<span class="hljs-number">59</span> 每分钟用<span class="hljs-operator">*</span>或者 <span class="hljs-operator">*/</span><span class="hljs-number">1</span>表示<br>eg:每十分钟执行一次： <span class="hljs-operator">*/</span><span class="hljs-number">10</span><br>第<span class="hljs-number">2</span>列表示小时<span class="hljs-number">1</span>～<span class="hljs-number">23</span>（<span class="hljs-number">0</span>表示<span class="hljs-number">0</span>点）<br>第<span class="hljs-number">3</span>列表示日期<span class="hljs-number">1</span>～<span class="hljs-number">31</span><br>第<span class="hljs-number">4</span>列表示月份<span class="hljs-number">1</span>～<span class="hljs-number">12</span><br>第<span class="hljs-number">5</span>列标识号星期<span class="hljs-number">0</span>～<span class="hljs-number">6</span>（<span class="hljs-number">0</span>表示星期天）<br>第<span class="hljs-number">6</span>列要运行的命令<br><br>日志：<br>如果没有指定日志，则日志默认存放在<span class="hljs-regexp">/var/</span>spool<span class="hljs-regexp">/mail/</span>root<br>如果在命令中指定日志，则日志在统计目录下，且<span class="hljs-regexp">/var/</span>spool<span class="hljs-regexp">/mail/</span>root下也会存储一份日志<br><br><br><br>实例：<br><span class="hljs-operator">*/</span><span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> cd <span class="hljs-regexp">/python_project/</span>dingshi_spider <span class="hljs-operator">&amp;&amp;</span> python3 test_debug.py <span class="hljs-operator">&gt;&gt;</span> run.log<br><span class="hljs-operator">-------</span>每一分钟执行一次，后面的是需要执行的linux命令，多个命令用<span class="hljs-operator">&amp;&amp;</span>链接，如果需要指定日志输出，用<span class="hljs-operator">&gt;&gt;</span>链接，后面跟上日志的名字，默认日志放在同级目录下<br><br><br>每<span class="hljs-number">1</span>分钟执行一次command<br><span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> command<br><br>每小时的第<span class="hljs-number">3</span>和第<span class="hljs-number">15</span>分钟执行<br><span class="hljs-number">3</span>,<span class="hljs-number">15</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> command<br><br>每个月的<span class="hljs-number">1</span>号， <span class="hljs-number">11</span>号， <span class="hljs-number">21</span>号 的<span class="hljs-number">2</span>：<span class="hljs-number">30</span>执行<br><span class="hljs-number">30</span>  <span class="hljs-number">2</span>   <span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">21</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> cmd<br><br>每天<span class="hljs-number">20</span>：<span class="hljs-number">00</span>至<span class="hljs-number">23</span>：<span class="hljs-number">00</span>，每半个小时执行一次<br><span class="hljs-number">0</span>,<span class="hljs-number">30</span> <span class="hljs-number">20</span><span class="hljs-operator">-</span><span class="hljs-number">23</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> cmd<br><br>在上午<span class="hljs-number">8</span>点到<span class="hljs-number">11</span>点的第<span class="hljs-number">3</span>和第<span class="hljs-number">15</span>分钟执行<br><span class="hljs-number">3</span>,<span class="hljs-number">15</span> <span class="hljs-number">8</span><span class="hljs-operator">-</span><span class="hljs-number">11</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> command<br><br>每隔两天的上午<span class="hljs-number">8</span>点到<span class="hljs-number">11</span>点的第<span class="hljs-number">3</span>和第<span class="hljs-number">15</span>分钟执行<br><span class="hljs-number">3</span>,<span class="hljs-number">15</span> <span class="hljs-number">8</span><span class="hljs-operator">-</span><span class="hljs-number">11</span> <span class="hljs-operator">*/</span><span class="hljs-number">2</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> command<br><br>每个星期一的上午<span class="hljs-number">8</span>点到<span class="hljs-number">11</span>点的第<span class="hljs-number">3</span>和第<span class="hljs-number">15</span>分钟执行<br><span class="hljs-number">3</span>,<span class="hljs-number">15</span> <span class="hljs-number">8</span><span class="hljs-operator">-</span><span class="hljs-number">11</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-number">1</span> command<br><br>每晚的<span class="hljs-number">21</span>:<span class="hljs-number">30</span>重启smb<br><span class="hljs-number">30</span> <span class="hljs-number">21</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">init</span>.d<span class="hljs-operator">/</span>smb restart<br><br>每月<span class="hljs-number">1</span><span class="hljs-operator">、</span><span class="hljs-number">10</span><span class="hljs-operator">、</span><span class="hljs-number">22</span>日的<span class="hljs-number">4</span>:<span class="hljs-number">45</span>重启smb<br><span class="hljs-number">45</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">22</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">init</span>.d<span class="hljs-operator">/</span>smb restart<br><br>每周六<span class="hljs-operator">、</span>周日的<span class="hljs-number">1</span>:<span class="hljs-number">10</span>重启smb<br><span class="hljs-number">10</span> <span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-number">6</span>,<span class="hljs-number">0</span> <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">init</span>.d<span class="hljs-operator">/</span>smb restart<br><br>每天<span class="hljs-number">18</span>:<span class="hljs-number">00</span>至<span class="hljs-number">23</span>:<span class="hljs-number">00</span>之间每隔<span class="hljs-number">30</span>分钟重启smb<br><span class="hljs-number">0</span>,<span class="hljs-number">30</span> <span class="hljs-number">18</span><span class="hljs-operator">-</span><span class="hljs-number">23</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">init</span>.d<span class="hljs-operator">/</span>smb restart<br><br>每星期六的晚上<span class="hljs-number">11</span>:00pm重启smb<br><span class="hljs-number">0</span> <span class="hljs-number">23</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-number">6</span> <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">init</span>.d<span class="hljs-operator">/</span>smb restart<br><br>每一小时重启smb<br><span class="hljs-number">0</span> <span class="hljs-operator">*/</span><span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">init</span>.d<span class="hljs-operator">/</span>smb restart<br><br>晚上<span class="hljs-number">11</span>点到早上<span class="hljs-number">7</span>点之间，每隔一小时重启smb<br><span class="hljs-operator">*</span> <span class="hljs-number">23</span><span class="hljs-operator">-</span><span class="hljs-number">7</span><span class="hljs-regexp">/1 * * * /</span>etc<span class="hljs-regexp">/init.d/</span>smb restart<br><br>每月的<span class="hljs-number">4</span>号与每周一到周三的<span class="hljs-number">11</span>点重启smb<br><span class="hljs-number">0</span> <span class="hljs-number">11</span> <span class="hljs-number">4</span> <span class="hljs-operator">*</span> mon<span class="hljs-operator">-</span>wed <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">init</span>.d<span class="hljs-operator">/</span>smb restart<br><br>一月一号的<span class="hljs-number">4</span>点重启smb<br><span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> jan <span class="hljs-operator">*</span> <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">init</span>.d<span class="hljs-operator">/</span>smb restart<br><br>每小时执行<span class="hljs-regexp">/etc/</span>cron.hourly目录内的脚本<br><span class="hljs-number">0</span> <span class="hljs-operator">*/</span><span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> root run<span class="hljs-operator">-</span>parts <span class="hljs-regexp">/etc/</span>cron.hourly<br><br><br>crontab每分钟定时执行：<br><span class="hljs-operator">*/</span><span class="hljs-number">1</span><span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> service mysqld restart<span class="hljs-comment">//每隔1分钟执行一次</span><br><span class="hljs-operator">*/</span><span class="hljs-number">10</span><span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> service mysqld restart<span class="hljs-comment">//每隔10分钟执行一次</span><br><br>crontab每小时定时执行：<br><span class="hljs-number">0</span> <span class="hljs-operator">*/</span><span class="hljs-number">1</span><span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> service mysqld restart<span class="hljs-comment">//每1小时执行一次</span><br><span class="hljs-number">0</span> <span class="hljs-operator">*/</span><span class="hljs-number">2</span><span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> service mysqld restart<span class="hljs-comment">//每2小时执行一次</span><br><br>crontab每天定时执行：<br><span class="hljs-number">0</span> <span class="hljs-number">10</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> service mysqld restart<span class="hljs-comment">//每天10点执行</span><br><span class="hljs-number">30</span> <span class="hljs-number">19</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> service mysqld restart<span class="hljs-comment">//每天19点30分执行</span><br><br>crontab每周定时执行：<br><span class="hljs-number">0</span> <span class="hljs-number">10</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-number">1</span> service mysqld restart<span class="hljs-comment">//每周一10点执行</span><br><span class="hljs-number">30</span> <span class="hljs-number">17</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-number">5</span> service mysqld restart<span class="hljs-comment">//每周五17点30分执行</span><br><br>crontab每年定时执行：<br><span class="hljs-number">0</span> <span class="hljs-number">10</span> <span class="hljs-number">1</span> <span class="hljs-number">10</span> <span class="hljs-operator">*</span> service mysqld restart<span class="hljs-comment">//每年的10月1日10点执行</span><br><span class="hljs-number">0</span> <span class="hljs-number">20</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-operator">*</span> service mysqld restart<span class="hljs-comment">//每年的8月8日20点执行</span><br><br><br>每分钟执行<span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span><br>每小时执行 <span class="hljs-number">0</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span><br>每天执行 <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span><br>每周执行 <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span> <span class="hljs-number">0</span><br>每月执行 <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-operator">*</span><br>每年执行 <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-operator">*</span><br>每小时的第<span class="hljs-number">3</span>和第<span class="hljs-number">15</span>分钟执行<span class="hljs-number">3</span>,<span class="hljs-number">15</span><span class="hljs-operator">****</span><br>上午<span class="hljs-number">8</span>点到<span class="hljs-number">11</span>点的第<span class="hljs-number">3</span>和第<span class="hljs-number">15</span>分钟执行<span class="hljs-number">3</span>,<span class="hljs-number">158</span><span class="hljs-operator">-</span><span class="hljs-number">11</span><span class="hljs-operator">***</span><br></code></pre></td></tr></table></figure><h3 id="mac上crontab的使用"><a href="#mac上crontab的使用" class="headerlink" title="mac上crontab的使用"></a>mac上crontab的使用</h3><ul><li><p>对crontab服务操作：</p><blockquote><p>sudo &#x2F;usr&#x2F;sbin&#x2F;cron start<br>sudo &#x2F;usr&#x2F;sbin&#x2F;cron restart<br>sudo &#x2F;usr&#x2F;sbin&#x2F;cron stop<br>sudo &#x2F;usr&#x2F;sbin&#x2F;cron status</p></blockquote></li><li><p>编辑定时任务</p><blockquote><p>sudo crontab -e</p></blockquote></li></ul><h2 id="nohup-后台运行"><a href="#nohup-后台运行" class="headerlink" title="nohup 后台运行"></a>nohup 后台运行</h2><ul><li>用途：不挂断地、后台运行命令。</li><li>语法：nohup Command [ Arg … ] [ &amp; ]</li><li>描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断（SIGHUP）信号。添加 &amp; 符号 到命令的尾部，表示在 后台运行 Command 命令 。</li><li>nohup .&#x2F;start-dishi.sh &gt;output 2&gt;&amp;1 &amp;</li><li>将标准错误 2 重定向到标准输出 &amp;1 ，标准输出 &amp;1 再被重定向输入到 runoob.log 文件中。<ul><li>0 – stdin (standard input，标准输入)</li><li>1 – stdout (standard output，标准输出)</li><li>2 – stderr (standard error，标准错误输出)</li></ul></li><li>解释：<ul><li>带&amp;的命令行，即使terminal（终端）关闭，或者电脑死机程序依然运行（前提是你把程序递交到服务器上)；</li><li>2&gt;&amp;1的意思</li><li>这个意思是把标准错误（2）重定向到标准输出中（1），而标准输出又导入文件output里面，所以结果是标准错误和标准输出都导入文件output里面了</li></ul></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">nohup ping www<span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span> &gt;ping<span class="hljs-selector-class">.log</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> &amp;<br>echo ping www<span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span> &gt;pingwww<span class="hljs-selector-class">.sh</span><br>sh pingwww<span class="hljs-selector-class">.sh</span><br>./pingwww<span class="hljs-selector-class">.sh</span><br>nohup ping www<span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span> &gt;ping<span class="hljs-selector-class">.log</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> &amp;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件安装</title>
    <link href="/blog/2018/05/03/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <url>/blog/2018/05/03/linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>Linux下的软件包可细分为两种，分别是</p><p><strong>源码包</strong></p><p><strong>二进制包</strong></p><p>二进制包是 Linux 下默认的软件安装包，因此二进制包又被称为默认安装软件包。</p><h6 id="目前主要有以下-2-大主流的二进制包管理系统："><a href="#目前主要有以下-2-大主流的二进制包管理系统：" class="headerlink" title="目前主要有以下 2 大主流的二进制包管理系统："></a>目前主要有以下 2 大主流的二进制包管理系统：</h6><p><strong>RPM 包管理系统</strong></p><p><strong>DPKG 包管理系统</strong></p><p><img src="/blog/images/mysql&linux/WEBRESOURCE39cc36d8b1ca8730d1710b7a43f39378%E6%88%AA%E5%9B%BE.png"></p><p><strong>yum</strong></p><p><strong>apt</strong></p><p><img src="/blog/images/mysql&linux/WEBRESOURCE2a61ac20f438a4376a6f160e72db4265%E6%88%AA%E5%9B%BE.png"></p><h3 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a><strong>apt-get</strong></h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>. sudo apt-<span class="hljs-keyword">get</span> install tree 安装tree<br><span class="hljs-number">2</span>. sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-comment">remove tree 卸载tree</span><br><span class="hljs-number">3</span>. sudo apt-<span class="hljs-keyword">get</span> update 更新软件<br><span class="hljs-number">4</span>. sudo apt-<span class="hljs-keyword">get</span> upgrade<br></code></pre></td></tr></table></figure><h3 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a><strong>rpm</strong></h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs subunit">*  检查某个软件是否安装<br># rpm -qa|grep java（查看java是否安装）<br>* 卸载已安装的软件<br># rpm -e --nodeps *****<br>同时卸载多个软件， 软件之间空格隔开<br>* 安装软件<br># rpm -ivh xxx.rpm<br><br><br>rpm -qa|grep java      #  查看java安装软件，通过 rpm 卸载低版本jdk<br>rpm -e --nodeps java<span class="hljs-string">-1</span>.8.0-openjdk-headless<span class="hljs-string">-1</span>.8.0.262.b10<span class="hljs-string">-1</span>.el7.x86_64<br>rpm -e --nodeps java<span class="hljs-string">-1</span>.8.0-openjdk<span class="hljs-string">-1</span>.8.0.262.b10<span class="hljs-string">-1</span>.el7.x86_64<br>rpm -e --nodeps java<span class="hljs-string">-1</span>.7.0-openjdk-headless<span class="hljs-string">-1</span>.7.0.261<span class="hljs-string">-2</span>.6.22.2.el7_8.x86_64<br>rpm -e --nodeps java<span class="hljs-string">-1</span>.7.0-openjdk<span class="hljs-string">-1</span>.7.0.261<span class="hljs-string">-2</span>.6.22.2.el7_8.x86_64<br></code></pre></td></tr></table></figure><h3 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a><strong>yum命令</strong></h3><blockquote><p>只针对于centos和redhat系统<br>需要配置源<br>软件包依赖关系以及各个软件的安装顺序 </p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># yum安装jdk</span><br>yum <span class="hljs-keyword">install </span><span class="hljs-keyword">java-11-openjdk-devel.x86_64</span><br><span class="hljs-keyword"></span><span class="hljs-comment"># yum安装redis</span><br>yum <span class="hljs-keyword">install </span>redis<br><span class="hljs-comment"># yum安装nginx</span><br>yum -y <span class="hljs-keyword">install </span>nginx<br><br></code></pre></td></tr></table></figure><h3 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a><strong>tar命令</strong></h3><blockquote><p><strong>用于安装tar包(tar包里面是源码， 需要编译)</strong><br>—– 不推荐使用源码编译方式安装， 较复杂<br><strong>zip软件相关操作</strong><br>前提： 需要linux上安装的是否有zip的操作包<br>检查命令： <strong>rpm -qa | grep zip</strong></p><p><strong>###  解压</strong><br><strong>$ unzip xxx.zip</strong><br><strong>### 压缩为zip文件</strong><br><strong>$ zip yyy.zip filename</strong><br><strong>tar软件相关操作</strong><br><strong>### 解压</strong><br>$ tar -zxvf xxx.tar.gz      （解压到当前目录）<br>$ tar -zxvf xxx.tar.gz -C dirpath    (解压到指定目录)</p><p><strong>## 压缩</strong><br>$ tar zcvf zzz.tar.gz dir&#x2F;filename</p></blockquote><h4 id="压缩包方式：linux安装jdk"><a href="#压缩包方式：linux安装jdk" class="headerlink" title="压缩包方式：linux安装jdk"></a><strong>压缩包方式：linux安装jdk</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">第一步： 使用FileZila将jdk包传到linux上<br>第二步： 使用tar -zxvf **jdk**.tar.gz<br>第三步：切换到root用户，配置环境变量<br><span class="hljs-comment"># vi /etc/profile</span><br>编辑内容如下<br><span class="hljs-comment">## JAVA_HOME</span><br>export JAVA_HOME=<span class="hljs-regexp">/opt/</span>java/jdk1.<span class="hljs-number">8.0</span>_381<br>export PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin<br>下一步：source一下，让命令生效<br>source <span class="hljs-regexp">/etc/</span>profile<br><span class="hljs-keyword">exit</span><br>第四步：检查<br>echo <span class="hljs-variable">$JAVA_HOME</span><br>echo <span class="hljs-variable">$PATH</span><br>java<br>java -version<br></code></pre></td></tr></table></figure><h4 id="压缩包方式：安装jdk11"><a href="#压缩包方式：安装jdk11" class="headerlink" title="压缩包方式：安装jdk11"></a><strong>压缩包方式：安装jdk11</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">1、先新建一个文件夹，<span class="hljs-built_in">mkdir</span> /usr/local/java<br>2、在宿主机执行 scp jdk-11.0.10_linux-x64_bin.tar.gz root@192.168.50.132:/usr/local/java2<br>3、在linux 执行<br>    <span class="hljs-built_in">cd</span>  /usr/local/java2/<br>    tar -zxvf jdk-11.0.10_linux-x64_bin.tar.gz<br>4、vi /etc/profile   <span class="hljs-comment"># 在 尾部添加如下内容：</span><br>    <span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/java/jdk-11.0.10<br>    <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin<br>    <span class="hljs-comment">#（！！！注意：JAVA_HOME的路径是你实际解压后的JDK的路径，千万别写错了）</span><br>5、<span class="hljs-built_in">source</span> /etc/profile   <span class="hljs-comment"># 刷新 配置文件</span><br>    java -version    <span class="hljs-comment"># 查看配置文件</span><br>    openjdk version <span class="hljs-string">&quot;1.8.0_262&quot;</span><br>    OpenJDK Runtime Environment (build 1.8.0_262-b10)<br>    OpenJDK 64-Bit Server VM (build 25.262-b10, mixed mode)<br></code></pre></td></tr></table></figure><h4 id="压缩包方式：安装tomcat"><a href="#压缩包方式：安装tomcat" class="headerlink" title="压缩包方式：安装tomcat"></a>压缩包方式：安装tomcat</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>、在宿主机上，下载地址<br>http:<span class="hljs-regexp">//</span>tomcat.apache.org/download-<span class="hljs-number">10</span>.cgi<br><span class="hljs-number">2</span>、在服务器上 先新建一个文件夹，<br>mkdir <span class="hljs-regexp">/usr/</span>local/tomcat<br><span class="hljs-number">3</span>、在宿主机上 ，执行下面命令 上传安装包<br>scp apache-tomcat-<span class="hljs-number">10.0</span>.<span class="hljs-number">5</span>.zip root@<span class="hljs-number">192.168</span>.<span class="hljs-number">50.132</span>:<span class="hljs-regexp">/usr/</span>local/tomcat<br><span class="hljs-number">4</span>、在服务器上 通过root用户 解压<br>unzip  apache-tomcat-<span class="hljs-number">10.0</span>.<span class="hljs-number">5</span>.zip<br>unzip -l apache-tomcat-<span class="hljs-number">10.0</span>.<span class="hljs-number">5</span>.zip  <span class="hljs-comment"># 只是查看 不解压</span><br><span class="hljs-number">5</span>、启动tomcat服务<br>cd apache-tomcat-<span class="hljs-number">10.0</span>.<span class="hljs-number">5</span>/bin<br>./startup.sh<br>chmod <span class="hljs-number">744</span> ./*.sh<br>./startup.sh<br><span class="hljs-number">6</span>、验证安装<br>netstat -nl  <span class="hljs-comment"># 找到 8080端口 是 LISTEN</span><br>ifconfig<br>systemctl status firewalld  <span class="hljs-comment">#查看防火墙状态</span><br>systemctl stop firewalld   <span class="hljs-comment">#禁用防火墙</span><br>在宿主机浏览器<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">50.132</span>:<span class="hljs-number">8080</span>/<br>显示：<br>Apache Tomcat/<span class="hljs-number">10.0</span>.<span class="hljs-number">5</span><br>If yo<span class="hljs-string">u&#x27;re seeing this, you&#x27;</span>ve successfully installed Tomcat. Congratulations!<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远程操作</title>
    <link href="/blog/2018/04/28/linux/%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C/"/>
    <url>/blog/2018/04/28/linux/%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a><strong>ifconfig</strong></h2><blockquote><p>ifconfig 可以查看／配置计算机当前的网卡配置信息<br>   $ ifconfig # 查看网卡配置信息<br>   $ ifconfig | grep inet # 查看网卡对应的 IP 地址<br>提示：一台计算机中有可能会有一个 物理网卡 和 多个虚拟网卡，在 Linux 中物理网卡的名字通常以 ensXX 表示</p></blockquote><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a><strong>ping</strong></h2><blockquote><p>$ ping IP地址 # 检测到目标主机是否连接正常<br>$ ping 127.0.0.1 # 检测本地网卡工作正常<br>ping 一般用于检测当前计算机到目标计算机之间的网络 是否通畅，数值越大，速度越慢<br>原理：网络上的机器都有 唯一确定的 IP 地址，我们给目标 IP 地址发送一个数据包，对方就要返回一个数据包，根据返回的数据包以及时间，我们可以确定目标主机的存在</p></blockquote><h2 id="ssh远程连接"><a href="#ssh远程连接" class="headerlink" title="ssh远程连接"></a>ssh远程连接</h2><h3 id="主机名和ip地址的映射"><a href="#主机名和ip地址的映射" class="headerlink" title="主机名和ip地址的映射"></a>主机名和ip地址的映射</h3><blockquote><p>修宿主机hosts 文件，添加ip地址和域名映射 。linux 也存在hosts 文件。<br>win：C:\Windows\System32\drivers\etc\hosts     linux：&#x2F;etc&#x2F;hosts<br>添加：<br>192.168.50.129  vmware.lnx01<br>192.168.50.128  vmware.lnx02<br>使用域名登录<br>ssh <a href="mailto:&#x72;&#x6f;&#111;&#x74;&#64;&#x76;&#109;&#x77;&#x61;&#114;&#101;&#x2e;&#108;&#110;&#x78;&#x30;&#49;">&#x72;&#x6f;&#111;&#x74;&#64;&#x76;&#109;&#x77;&#x61;&#114;&#101;&#x2e;&#108;&#110;&#x78;&#x30;&#49;</a></p></blockquote><h3 id="修改linux主机名"><a href="#修改linux主机名" class="headerlink" title="修改linux主机名"></a>修改linux主机名</h3><blockquote><p>Linux系统安装好后，都会有默认的主机名， CentOS系统默认的主机名是localhost.localdomain，为了便于使用，我们常常需要修改主机名<br>1.显示主机名称： hostname  |  uname -n | hostnamectl<centos7><br>2.设置主机名称：hostname 名称<br>     注意：这种方式设置主机名称，仅仅在当前使用没有问题，当机器重启之后，主机名称会变化。<br>     原因：在linux系统中，系统配置的信息都是来自于文件中，这种设置方式没有写入文件中<br>3.永久设置主机名称：      cat &#x2F;etc&#x2F;system-release: 查看服务器的linux版本<br>      方式1：hostnamectl set-hostname vm_lnx  #修改主机名, 重新连接主机即可看到主机名发生了改变，不需要重启机器<br>      方式2：centos7.3 前的系统<br>             1：cat &#x2F;etc&#x2F;sysconfig&#x2F;network   (cat  文件名： 读取文件内容)<br>             2    vi &#x2F;etc&#x2F;sysconfig&#x2F;network<br>             3    编辑hostname&#x3D;主机名<br>             4    重启系统：关机：# halt     |      重启：reboot &#x2F; init6(安全重启) &#x2F; shutdown<br>    方式3：centos7.3 后的系统修改&#x2F;etc&#x2F;hostname 文件内容，并重启生效</p><p>注意：centos上再重命名主机名字的时候， 主机名字不要使用  下划线_,   会出现很多错误</p></blockquote><h3 id="简单连接"><a href="#简单连接" class="headerlink" title="简单连接"></a>简单连接</h3><blockquote><p>ssh [-p port]<br>•user 是在远程机器上的用户名，如果不指定的话默认为当前用户<br>•remote 是远程机器的地址，可以是 IP／域名，或者是 后面会提到的别名<br>•port 是 SSH Server 监听的端口，如果不指定，就为默认值 22<br>使用 exit 退出当前用户的登录<br>SSH 服务器的端口号很有可能不是 22，如果遇到这种情况就需要使用 -p 选项，指定正确的端口号，否则无法正常连接到服务器</p></blockquote><h3 id="免密码连接"><a href="#免密码连接" class="headerlink" title="免密码连接"></a>免密码连接</h3><blockquote><ol><li>生成钥匙，一路回车：ssh-keygen</li><li>配置公钥到服务器：<br>  a. ssh-copy-id -p port user@remote，可以让远程服务器记住我们的公钥<br>  b. win不支持a命令，可以手动配置：将生成的id_rsa.pub内容拷贝到authorized_keys文件中</li></ol></blockquote><h2 id="scp远程拷贝"><a href="#scp远程拷贝" class="headerlink" title="scp远程拷贝"></a>scp远程拷贝</h2><blockquote><p>远程复制：<br>      scp file root@ip:dir 上传<br>      scp root@ip:file &#x2F;dir 下载<br>选项<br>      -r 若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名<br>      -P 若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端</p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment"># 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py</span><br><span class="hljs-comment"># 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径</span><br>scp -P port <span class="hljs-number">01</span>.py user<span class="hljs-variable">@remote</span><span class="hljs-symbol">:Desktop/</span><span class="hljs-number">01</span>.py<br>scp -P port user<span class="hljs-variable">@remote</span><span class="hljs-symbol">:Desktop/</span><span class="hljs-number">01</span>.py <span class="hljs-number">01</span>.py <span class="hljs-comment"># 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.py</span><br>scp -r demo user<span class="hljs-variable">@remote</span><span class="hljs-symbol">:/opt/yyang25</span>  <span class="hljs-comment"># 加上 -r 选项可以传送文件夹,把当前目录下的 demo 文件夹 复制到 远程 家目录下的 /opt/yyang25</span><br>scp -r user<span class="hljs-variable">@remote</span><span class="hljs-symbol">:Desktop</span> demo         <span class="hljs-comment"># 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹</span><br><br>scp jdk<span class="hljs-number">-11.0</span>.<span class="hljs-number">12_</span>linux-x64_bin.tar.gz <span class="hljs-title class_">SERVER_USERNAME</span><span class="hljs-variable">@HOSTNAME_OR_IP</span><span class="hljs-symbol">:</span>.<br><span class="hljs-symbol">:</span>后面跟路径<br><span class="hljs-symbol">example:</span> scp <span class="hljs-symbol">D:</span>\<span class="hljs-title class_">Users</span>\yyang25\<span class="hljs-title class_">Downloads</span>\test.apk root<span class="hljs-variable">@182</span>.<span class="hljs-number">92.164</span>.<span class="hljs-number">32</span><span class="hljs-symbol">:</span>. --&gt;.表示上传到home目录<br><span class="hljs-symbol">example:</span> scp <span class="hljs-symbol">D:</span>\<span class="hljs-title class_">Users</span>\yyang25\<span class="hljs-title class_">Downloads</span>\test.apk root<span class="hljs-variable">@182</span>.<span class="hljs-number">92.164</span>.<span class="hljs-number">32</span><span class="hljs-symbol">:/opt/yyang25/software</span> --&gt;<span class="hljs-symbol">:</span>后面跟路径<br><span class="hljs-symbol">example:</span> scp  root<span class="hljs-variable">@182</span>.<span class="hljs-number">92.164</span>.<span class="hljs-number">32</span><span class="hljs-symbol">:/opt/yyang25/software/test</span>.apk <span class="hljs-symbol">D:</span>\<span class="hljs-title class_">Users</span>\yyang25\<span class="hljs-title class_">Downloads</span> --&gt;从远程拉取文件<br><span class="hljs-symbol">example:</span> scp  root<span class="hljs-variable">@182</span>.<span class="hljs-number">92.164</span>.<span class="hljs-number">32</span><span class="hljs-symbol">:</span>./test.apk root<span class="hljs-variable">@182</span>.<span class="hljs-number">92.164</span>.<span class="hljs-number">32</span><span class="hljs-symbol">:</span>. --&gt;两个服务器之间推拉文件; 注意：需要在服务器配置公钥，比如scp a b; 要把b服务器home目录下.ssh目录中把公钥复制到a服务器下.ssh/目录下的auth..keys文件中<br></code></pre></td></tr></table></figure><h2 id="Rsync远程数据同步"><a href="#Rsync远程数据同步" class="headerlink" title="Rsync远程数据同步"></a>Rsync远程数据同步</h2><p>Rsync（remote synchronize）是一个远程数据同步工具，可通过LAN&#x2F;WAN快速同步多台主机间的文件。Rsync使用所谓的“Rsync算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。</p><p>rsync [OPTION]… SRC DEST</p><p>rsync [OPTION]… SRC [USER@]HOST:DEST</p><p>rsync [OPTION]… [USER@]HOST:SRC DEST</p><p>源目录加了斜线，效果就是将该目录下的内容传输到目标目录下。</p><p>源目录不加斜线，效果就是将该目录传输到目标目录下。</p><p>目标目录如果不存在，会自动创建目标目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rsync -avlK ./d2 ./d3 <span class="hljs-comment">#同步目录</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件管理</title>
    <link href="/blog/2018/04/26/linux/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <url>/blog/2018/04/26/linux/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a><strong>文件</strong></h1><h2 id="linux下文件类型-常见三种文件-："><a href="#linux下文件类型-常见三种文件-：" class="headerlink" title="linux下文件类型(常见三种文件)："></a><strong>linux下文件类型(常见三种文件)：</strong></h2><blockquote><p>***** 文件：表示符： <strong>-</strong><br>*** <strong>目录(类似win7下的文件夹)：表示符：</strong>d**<br>*** <strong>链接(类似win7下的快捷方式)：表示符：</strong>l**</p></blockquote><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a><strong>文件权限</strong></h2><blockquote><ul><li>可读  r</li><li>可写  w</li><li>可执行(针对脚本，比如shell脚本)  x</li><li>特殊字符：<br><strong>-</strong>**  表示没有任何权限**</li></ul><p>权限的数字表示方法：<br>*** rw-  **     —&gt; 6<br>*** 二进制数字之和的方式**<br>R          W        X<br>2^2      2^1      2^0<br>  4          2          1  </p></blockquote><h2 id="文件归属"><a href="#文件归属" class="headerlink" title="文件归属"></a><strong>文件归属</strong></h2><blockquote><ul><li>拥有着    owner  ** u**</li><li>属于组    grouip   <strong>g</strong></li><li>其他人    other   **  o**</li></ul></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">-rw-rw-r--   <span class="hljs-number">2</span> <span class="hljs-keyword">beifeng </span><span class="hljs-keyword">beifeng </span><span class="hljs-number">4096</span> May <span class="hljs-number">30</span> <span class="hljs-number">15</span>:<span class="hljs-number">15</span> <span class="hljs-keyword">bin</span><br><span class="hljs-keyword"></span><br>第一部分：-rw-rw-r--<br>十个字符，代表不同的意义<br>-   rw-   rw-    r--       ----&gt;  数字表示权限：<span class="hljs-number">664</span><br>第一个字符：<br>表示的是文件的类型<br>后面的<span class="hljs-number">9</span>个字符，分为<span class="hljs-number">3</span>组，表示的是此文件针对不同用户的权限关系<br>为什么是三组呢？<br>因为一个文件对于用户来说，属于三个部分<br>* 拥有着    rw-<br>* 所属组    rw-<br>* 其他人    r--<br>第二部分：<span class="hljs-number">2</span>       硬链接数，通俗地讲，就是有多少种方式，可以访问到当前目录／文件<br>第三部分：<span class="hljs-keyword">beifeng </span><span class="hljs-keyword">beifeng</span><br><span class="hljs-keyword"></span>* 第一个字符串表示的是   文件的拥有者，<span class="hljs-keyword">beifeng </span><br>* 第二个字符串表示的是   文件所属组， <span class="hljs-keyword">beifeng</span><br><span class="hljs-keyword"></span><br>第四部分：<span class="hljs-number">4096</span><br>如果是文件夹，表示文件夹中多少文件<br>如果是文件，表示文件大小<br></code></pre></td></tr></table></figure><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a><strong>创建文件</strong></h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>. 使用touch命令： touch test.py<br><span class="hljs-symbol">2 </span>使用vi/vim方式：本意是修改文件，如果不存在，则创建：$ vi test.py<br><span class="hljs-symbol">3 </span>使用echo命令， 覆盖 | 追加：对文件内容进行追加  $ echo <span class="hljs-string">&quot;******&quot;</span>  &gt;&gt; text.py<br></code></pre></td></tr></table></figure><h3 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a><strong>编辑文件</strong></h3><ul><li><p>vi | vim：</p><blockquote><p>1.dd：表示删除光标所在行的内容<br>2. u: 撤销上次命令<br>3. ctrl + r: 恢复撤销的命令<br>4. o：表示光标进入下一行，并进行插入数据模式<br>5. 异常处理&#x2F;交换文件：vim -r 文件名: 恢复交换文件；rm *.swp：删除交换文件<br>6. shift + G: vi跳到文件末尾</p></blockquote></li><li><p>echo：</p><blockquote><p>追加内容至末尾：echo aaaaa &gt;&gt; 1.txt<br>覆盖原有内容：echo aaaaa &gt; 1.txt</p></blockquote></li></ul><h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a><strong>查看文件</strong></h3><ul><li><p>wc：统计文本中行数、字数、字符数</p></li><li><p>cat：查看文件的全部内容， 适用于文件内容较小的文件</p></li><li><p>more： 翻页查看，适用于文件内容较大的文件</p></li></ul><blockquote><p>回车多显示一行，空格就一页一页的走<br>:q  退出查看</p></blockquote><ul><li>less：翻页查看，more只能往后翻，less可以往前</li></ul><blockquote><p>回车多显示一行，空格就一页一页的走<br>:q  退出查看<br>b：回滚一屏<br>f：前滚一屏</p></blockquote><ul><li>tail：从文件末尾开始查看</li></ul><blockquote><p><strong>通常与  -f   参数连用，适合查看服务的实时动态的日志信息</strong><br>eg：<br>tail -f  ****.log<br>tail -200f  ****.log       (查看日志文件最后的两百行日志)</p></blockquote><ul><li><p>head：查看文件的开头文件， 通常用于查看文件格式，内容模板样式</p></li><li><p>grep：匹配文件内容</p></li></ul><blockquote><p>-c 仅列出文件中包含模式的行数。<br>-i 忽略模式中的字母大小写。<br>参数<br>    ^a 行首，搜寻以 a 开头的行<br>    ke$ 行尾，搜寻以 ke 结束的行</p></blockquote><blockquote><p>grep Setup 1.txt<br>grep setup 1.txt<br>grep -i setup 1.txt： -i  忽略大小写<br>grep -c setup 1.txt<br>grep -ic setup 1.txt<br>grep ^% 1.txt<br>grep -i c$ 1.txt<br>grep -i [a-z]ystem 1.txt</p></blockquote><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="**删除文件"></a>**删除文件</h3><blockquote><p>**<strong>rm；</strong>-f 强制删除，忽略不存在的文件，无需提示；-r 递归删除目录下的内容</p></blockquote><h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="**拷贝文件"></a>**拷贝文件</h3><blockquote><p>**cp；-i 覆盖文件前提示； -r 若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</p></blockquote><h3 id="合并文件"><a href="#合并文件" class="headerlink" title="**合并文件"></a>**合并文件</h3><blockquote><p>**cat  可以文件合并：cat  file1 file2 &gt; file3</p></blockquote><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="**移动文件"></a>**移动文件</h3><blockquote><p>**mv；-i 默认选项，覆盖文件前提示； -f 强制覆盖，不提示；-b 当目标文件存在时，先进行备份在覆盖</p></blockquote><h3 id="搜索文件"><a href="#搜索文件" class="headerlink" title="**搜索文件"></a>**搜索文件</h3><blockquote><p>**find 搜索路径 -name 搜索文件名；</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> ~/ -name ab.txt<br><span class="hljs-built_in">find</span> ~/ -name ab\*    (模糊查询)<br></code></pre></td></tr></table></figure><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><ol><li><p>创建目录：mkdir；-p 可以递归创建目录。同级的目录或文件，都不能重名</p></li><li><p>删除目录：<strong>rm；</strong>-f 强制删除，忽略不存在的文件，无需提示；-r 递归地删除目录下的内容</p></li><li><p>拷贝目录：cp；-i 覆盖文件前提示； -r 若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</p></li><li><p>移动目录：mv；-i 默认选项，覆盖文件前提示； -f 强制覆盖，不提示；-b 当目标文件存在时，先进行备份在覆盖</p></li><li><p>查看路径：pwd</p></li><li><p>树形结构查看目录：tree；需要安装tree包 sudo apt-get install tree</p></li><li><p>查看文件详细信息：stat；比ls更详细</p></li><li><p>查看目录：ls；-l  列出文件详细信息l(list)；-a  列出当前目录下所有文件及目录，包括隐藏的a(all)</p></li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ls</span> -<span class="hljs-keyword">l</span>  # 列出可见文件详细信息<br><span class="hljs-keyword">ll</span>     # 列出可见文件详细信息  等效 <span class="hljs-keyword">ls</span> -<span class="hljs-keyword">l</span><br><span class="hljs-keyword">ls</span> -<span class="hljs-keyword">al</span> # 列出所有文件详细信息，包括隐藏文件<br><span class="hljs-keyword">ll</span> -<span class="hljs-keyword">a</span>  # 列出所有文件详细信息，包括隐藏文件 等效 <span class="hljs-keyword">ll</span> -<span class="hljs-keyword">a</span><br><span class="hljs-keyword">ll</span> -ah<br><span class="hljs-keyword">ll</span> dirname：列出dirname目录下的文件<br><br>占位符：* 匹配多个；?匹配一个<br><span class="hljs-keyword">ll</span> <span class="hljs-keyword">y</span>*<br><span class="hljs-keyword">ll</span> *.txt<br><br><span class="hljs-keyword">ll</span> <span class="hljs-keyword">y</span>*d*<br><span class="hljs-keyword">ll</span> <span class="hljs-keyword">y</span>??<br><span class="hljs-keyword">ll</span> /usr/bin # 列出指定路径的文件信息<br></code></pre></td></tr></table></figure><h2 id="连接："><a href="#连接：" class="headerlink" title="连接："></a><strong>连接：</strong></h2><blockquote><p>软连接：相当于win7快捷键<br>硬连接：相当于拷贝文件<br>区别：在删除链接时，是否删除源文件</p></blockquote><ol><li><p>创建软连接：ln -s file&#x2F;dir linkName</p></li><li><p>创建硬连接：ln file&#x2F;dir linkName</p></li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment">## 创建一个软链接</span><br><span class="hljs-built_in">ln</span> -s readme.txt link.txt<br>lrwxrwxrwx. <span class="hljs-number">1</span> baby baby    <span class="hljs-number">4</span> Jun  <span class="hljs-number">9</span> <span class="hljs-number">02</span>:<span class="hljs-number">24</span> rm.txt -&gt; <span class="hljs-keyword">a</span>.py<br><span class="hljs-comment">## 创建一个硬链接</span><br>$ <span class="hljs-built_in">ln</span> ab.txt baby.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2><ol><li><p>chmod：设置文件对不同用户的权限，需要使用root用户</p></li><li><p>chgrp：修改组</p></li><li><p>chown：修改拥有者</p></li></ol><blockquote><p>chown 用户名 文件名|目录名 # 修改文件|目录的拥有者<br>chgrp -R 组名 文件名|目录名 # 递归修改文件|目录的组<br>chmod -R 755 文件名|目录名 # 递归修改文件权限<br>chmod 在设置权限时，可以简单地使用三个数字分别对应拥有者／ 组和其他用户的权限<br>直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他<br>chmod +&#x2F;-rwx 文件名|目录名 # 一次性修改 拥有者 &#x2F; 组 权限</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># chmod</span><br>eg: -rw-rw-r--. 1 baby baby 0 May 31 16:02 a.py<br>需求：对于同组用户来说，仅仅可读，对于其他用户不可读不可写<br>    权限字符形式操作：<br>        <span class="hljs-comment"># chmod  g-w a.py      (表示对于同组u用户，删除可写权限)</span><br>        <span class="hljs-comment"># chmod  o-r a.py    (表示对于其他用户，删除读和写权限)</span><br>        <span class="hljs-comment"># chmod g-r-w a.py  (表示对于同组用户，删除读和写权限)</span><br>    <br>    权限数字形式权限：<br>        <span class="hljs-comment"># chmod 664  (表示对拥有着可读可写，同组用户可读可写，其他用户可读)</span><br><br>    问题：如果针对一个目录，设置权限呢？且目录中有许多文件，这些文件都需要同样的权限设置。<br>        -R, --recursive  递归<br>        <span class="hljs-comment"># chmod -R 664 /opt/softwares</span><br><br><span class="hljs-comment"># chown</span><br>    <span class="hljs-built_in">chown</span> baby /home/a.py<br><span class="hljs-comment"># chgrp</span><br>    <span class="hljs-built_in">chgrp</span> baby /home/a.py<br>    经测，两个命令都要运行，才会改变(不一定)<br><span class="hljs-comment"># 如果针对目录：递归</span><br>    <span class="hljs-built_in">chown</span> -R baby /opt/softwares<br>    <span class="hljs-built_in">chgrp</span> -R baby /opt/softwares<br><span class="hljs-comment"># 将/home/a.py文件的所属用户和所属组改为senior用户和senior组</span><br>    可以使用一个命令完成：<br>    <span class="hljs-built_in">chown</span> senior:senior /home/a.py<br>    senior:senior: 第一个senior代表用户，第二个senior代表组<br></code></pre></td></tr></table></figure><h2 id="打包与压缩"><a href="#打包与压缩" class="headerlink" title="打包与压缩"></a>打包与压缩</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a><strong>tar</strong></h3><blockquote><p>c 生成档案文件，创建打包文件<br>x 解开档案文件<br>v 列出归档解档的详细过程，显示进度<br>f 指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后，其他选项顺序可以随意<br>z 可以调用gzip进行压缩</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">tar -cvf 打包文件<span class="hljs-string">.tar</span> 被打包的文件／路径 <span class="hljs-comment"># 打包文件</span><br>tar -xvf 打包文件<span class="hljs-string">.tar</span> <span class="hljs-comment"># 解包文件</span><br>tar -zcvf 打包文件<span class="hljs-string">.tar.gz</span> 要被压缩的文件/路径   <span class="hljs-comment"># 压缩文件</span><br>tar -zxvf filename.tar.gz                     <span class="hljs-comment"># 解压缩文件</span><br>tar -zxvf filename.tar.gz -C 目标路径         <span class="hljs-comment"># 解压缩到指定路径；选项-C 解压缩到指定目录，注意：要解压缩的目录必须存在 </span><br></code></pre></td></tr></table></figure><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a><strong>zip</strong></h3><p><strong>zip</strong></p><blockquote><p>zip -q -r html.zip &#x2F;home&#x2F;html # 将 &#x2F;home&#x2F;html&#x2F; 这个目录下所有文件和文件夹打包为当前目录下的 html.zip<br>zip -q -r html.zip * # 如果在我们在 &#x2F;home&#x2F;html 目录下<br>zip -dv cp.zip a.c #从压缩文件 cp.zip 中删除文件 a.c</p></blockquote><p><strong>unzip</strong></p><blockquote><p>unzip -l abc.zip #查看压缩文件中包含的文件<br>unzip abc.zip -d&lt;目录&gt; # 指定文件解压缩后所要存储的目录</p></blockquote><p><strong>查看命令的路径</strong></p><blockquote><p>whereis java</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础知识</title>
    <link href="/blog/2017/03/26/linux/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/blog/2017/03/26/linux/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h3 id="linux的发行版本"><a href="#linux的发行版本" class="headerlink" title="linux的发行版本"></a>linux的发行版本</h3><p><img src="/blog/images/mysql&linux/WEBRESOURCEdea7cd4b5044f1814039227aa57292f3%E6%88%AA%E5%9B%BE.png"></p><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><ul><li>Linux下的软件包可细分为两种，分别是<strong>源码包</strong>和<strong>二进制包</strong></li><li>源码包就是一大堆源代码程序，一般包含多个文件，为了方便发布，通常会将源码包做打包压缩处理，Linux 中最常用的打包压缩格式为“tar.gz”，因此源码包又被称为 Tarball。因为可能会需要一些依赖环境，所以安装前就需要先安装这些依赖环境</li><li>二进制包：是源码包经过成功编译之后产生的包。由于二进制包在发布之前就已经完成了编译的工作，因此用户安装软件的速度较快（同 Windows下安装软件速度相当），且安装过程报错几率大大减小。因为已经编译过，依赖环境已经编译进二进制文件中，所以会省去很多麻烦</li><li>二进制包是 Linux 下默认的软件安装包，因此二进制包又被称为默认安装软件包。</li></ul><h4 id="目前主要有以下-2-大主流的二进制包管理系统："><a href="#目前主要有以下-2-大主流的二进制包管理系统：" class="headerlink" title="目前主要有以下 2 大主流的二进制包管理系统："></a>目前主要有以下 2 大主流的二进制包管理系统：</h4><p><strong>RPM 包管理系统</strong>： 功能强大，安装、升级、査询和卸载非常简单方便，因此很多 Linux 发行版都默认使用此机制作为软件安装的管理方式，例如 Fedora、CentOS、SuSE 等</p><p><strong>DPKG 包管理系统</strong>： 由 Debian Linux 所开发的包管理机制，通过 DPKG 包，Debian Linux 就可以进行软件包管理，主要应用在 Debian 和 Ubuntu 中</p><p><img src="/blog/images/mysql&linux/WEBRESOURCE9731d18bcb5321cfa264a5153b5dbc4a%E6%88%AA%E5%9B%BE.png"></p><p><strong>yum</strong>：全称“Yellow dog Updater, Modified”，是一个专门为了解决包的依赖关系而存在的软件包管理器。就好像 Windows 系统上可以通过 360 软件管家实现软件的一键安装、升级和卸载</p><p><strong>apt</strong>：是 Advanced Packaging Tool，是 Linux 下的一款安装包管理工具，可以在终端中方便的 安装／卸载／更新软件包</p><p><img src="/blog/images/mysql&linux/WEBRESOURCEe65ac98f274d246b4cac2da80154c292%E6%88%AA%E5%9B%BE.png"></p><h3 id="Linux的设计思想：一切皆文件"><a href="#Linux的设计思想：一切皆文件" class="headerlink" title="Linux的设计思想：一切皆文件"></a>Linux的设计思想：一切皆文件</h3><p>Linux 中所有内容都是以文件的形式保存和管理的，即一切皆文件 。具体可分为以下几种类型：</p><ol><li>- 普通文件：类似 mp4、pdf、html 这样，可直接拿来使用的文件都属于普通文件</li><li>d 目录文件：目录文件包含了此目录中各个文件的文件名以及指向这些文件的指针，打开目录等同于打开目录文件，只要你有权限，可以随意访问目录中的任何文件。</li><li>c 字符设备文件：这些文件通常隐藏在 &#x2F;dev&#x2F; 目录下，当进行设备读取或外设交互时才会被使用。例如，磁盘光驱属于块设备文件，串口设备则属于字符设备文件。 Linux 系统中的所有设备，要么是块设备文件，要么是字符设备文件。 </li><li>s 套接字文件（socket）：套接字文件一般隐藏在 &#x2F;var&#x2F;run&#x2F; 目录下，用于进程间的网络通信。 </li><li>l 链接文件（symbolic link）：类似与 Windows 中的快捷方式，是指向另一文件的简介指针（也就是软链接）。 </li><li>p 管道文件（pipe）：主要用于进程间通信。例如，使用 mkfifo 命令创建一个 FIFO 文件，与此同时，启用进程 A 从FIFO文件读数据，启用进程 B 从 FIFO文件中写数据，随写随读。</li></ol><h3 id="Linux文件目录结构"><a href="#Linux文件目录结构" class="headerlink" title="Linux文件目录结构"></a>Linux文件目录结构</h3><ul><li>&#x2F;：根目录，一般根目录下只存放目录，不要存放文件，&#x2F;etc、&#x2F;bin、&#x2F;dev、&#x2F;lib、&#x2F;sbin应该和根目录放置在一个分区中  </li><li>&#x2F;bin: &#x2F;usr&#x2F;bin:可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。 </li><li>&#x2F;boot：放置linux系统启动时用到的一些文件，比如内核文件和启动引导文件。&#x2F;boot&#x2F;vmlinuz为linux的内核文件，以及&#x2F;boot&#x2F;gurb。建议单独分区，分区大小100M即可 </li><li>&#x2F;dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount &#x2F;dev&#x2F;cdrom &#x2F;mnt。 </li><li>&#x2F;etc：系统配置文件存放的目录，系统通过rpm默认安装方式的配置文件全都在这个目录。不建议在此目录下存放可执行文件，重要的配置文件有&#x2F;etc&#x2F;inittab、&#x2F;etc&#x2F;fstab、&#x2F;etc&#x2F;init.d、&#x2F;etc&#x2F;X11、&#x2F;etc&#x2F;sysconfig、&#x2F;etc&#x2F;xinetd.d修改配置文件之前记得备份。 注：&#x2F;etc&#x2F;X11存放与x windows有关的设置。 </li><li>&#x2F;home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，<del>表示当前用户的家目录，</del>test表示用户test的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据 </li><li>&#x2F;lib:&#x2F;usr&#x2F;lib:&#x2F;usr&#x2F;local&#x2F;lib：系统调用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为&#x2F;lib&#x2F;modules。</li><li>&#x2F;mnt:&#x2F;media:&#x2F;misc：光盘默认挂载点，通常光盘挂载于&#x2F;mnt&#x2F;cdrom下，也不一定，可以选择任意位置进行挂载 </li><li>&#x2F;opt：给主机额外安装软件所摆放的目录,即第三方软件的安装位置。手工安装的包都可以放在这个位置。如：FC4使用的Fedora 社群开发软件，如果想要自行安装新的KDE 桌面软件，可以将该软件安装在该目录下。以前的 Linux 系统中，习惯放置在 &#x2F;usr&#x2F;local 目录下</li><li>&#x2F;root：系统管理员root的家目录，系统第一个启动的分区为&#x2F;，所以最好将&#x2F;root和&#x2F;放置在一个分区下。</li><li>&#x2F;sbin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;sbin：放置系统管理员使用的可执行命令即系统环境设置相关命令，如fdisk、shutdown、mount等。与&#x2F;bin不同的是，这几个目录是给系统管理员root使用的命令，一般用户只能”查看”而不能设置和使用。</li><li>&#x2F;srv：服务启动之后需要访问的数据目录，如www服务需要访问的网页数据存放在&#x2F;srv&#x2F;www内</li><li>&#x2F;tmp：一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下</li><li>&#x2F;proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有&#x2F;proc&#x2F;cpuinfo、&#x2F;proc&#x2F;interrupts、&#x2F;proc&#x2F;dma、&#x2F;proc&#x2F;ioports、&#x2F;proc&#x2F;net&#x2F;*等</li><li>&#x2F;lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。如加载硬盘于&#x2F;disk 中，此目录下就会自动产生目录&#x2F;disk&#x2F;lost+found </li><li>&#x2F;usr：应用程序存放目录，全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 &#x2F;usr 目录下的各子目录中，而不是为他们的产品创建单独的目录。&#x2F;usr&#x2F;bin存放应用程序，&#x2F;usr&#x2F;share存放共享数据，&#x2F;usr&#x2F;lib存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。&#x2F;usr&#x2F;local:存放软件升级包。&#x2F;usr&#x2F;share&#x2F;doc:系统说明文件存放目录。&#x2F;usr&#x2F;share&#x2F;man:?程序说明文件存放目录，使用 man ls时会查询&#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;ls.1.gz的内容建议单独分区，设置较大的磁盘空间</li></ul><p><img src="/blog/images/mysql&linux/WEBRESOURCEd609518d33a119b1d3f1200067f3950d%E6%88%AA%E5%9B%BE.png"></p><ul><li>&#x2F;var：放置系统执行过程中经常变化的文件，如随时更改的日志文件&#x2F;var&#x2F;log，&#x2F;var&#x2F;log&#x2F;message：所有的登录文件存放目录，&#x2F;var&#x2F;spool&#x2F;mail：邮件存放的目录，&#x2F;var&#x2F;run:程序或服务启动后，其PID存放在该目录下。建议单独分区，设置较大的磁盘空间</li></ul><p><img src="/blog/images/mysql&linux/WEBRESOURCEfd92c04351383b1e3171fb103f8757cc%E6%88%AA%E5%9B%BE.png"></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
